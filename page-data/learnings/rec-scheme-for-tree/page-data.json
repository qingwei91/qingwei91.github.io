{"componentChunkName":"component---src-templates-blog-post-js","path":"/learnings/rec-scheme-for-tree/","result":{"data":{"site":{"siteMetadata":{"title":"All models are wrong","author":"Qing Wei"}},"markdownRemark":{"id":"9322c98c-caa7-507b-8775-0cb6b72f54da","excerpt":"Lately, I am learning  algorithm, which is a kind of algorithm to check if a particular system is linearizable or not. Informally, a system…","html":"<p>Lately, I am learning <code class=\"language-text\">Linearizability check</code> algorithm, which is a kind of algorithm to check if a particular system is linearizable or not.</p>\n<p>Informally, a system is linearizable if concurrent operations against the system can be arranged in a sequential way (called lineage) such that the lineage is <strong>consistent</strong> with a sequential model of the system.</p>\n<p>That’s quite a mouthful, it might be easier to grasp by using examples, say you have a system X that is capable of storing an integer value (ie. a registry), and 2 clients A, and B that can read and write the value.</p>\n<p>Below is the operations that A and B execute respectively.</p>\n<table>\n<thead>\n<tr>\n<th>A</th>\n<th>B</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Set 2</td>\n<td>Set 3</td>\n</tr>\n<tr>\n<td>Read 2</td>\n<td>Read 3</td>\n</tr>\n<tr>\n<td>Read 3</td>\n<td>Set 1</td>\n</tr>\n</tbody>\n</table>\n<p>Let’s assume operations within a process needs to happens in the given order, but operations between processes can happen in any order, and our goal is to find a specific order that is consistent with a sequential model, for example</p>\n<p><code class=\"language-text\">A Set 2 -> B Set 3 -> B Read 3 -> A Read 2 -> A Read 3 -> B Set 1</code></p>\n<p>is a lineage that is not correct because we should not be reading <code class=\"language-text\">2</code> at the 4th operation, it should be <code class=\"language-text\">3</code></p>\n<p><code class=\"language-text\">A Set 2 -> A Read 2 -> B Set 3 -> B Read 3 -> A Read 3 -> B Set 1</code></p>\n<p>is a valid lineage.</p>\n<p>If we are able to find a lineage that is correct, then the history is linearizable, note that this does not means that the system is linearizable, like all example based test, linearizable test is not able to proof there’s no bug, nevertheless it is still very useful.</p>\n<h2>How it works?</h2>\n<p>There are many different algorithms to test for linearizability.</p>\n<p>Essentially, it is a kind of Constrained Satisfiable Problem, some smart people managed to prove that it is a NP-hard problem.</p>\n<p>The algorithm is about how to find a valid lineage in a massive search space.</p>\n<p>Like many search algorithm, it can leverage backtracking, here’s the logic.</p>\n<p>The input is a collection of operations called <code class=\"language-text\">history</code>, each operation contains</p>\n<ul>\n<li>request</li>\n<li>response</li>\n<li>requestor (eg. process id)</li>\n</ul>\n<p>We also need a <code class=\"language-text\">sequential model</code>, which specify how the system under test should behaves if all operations happen sequentially. For the logic below, we will assume model is immutable, and every operation produces a new model</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">lin_check</span><span class=\"token punctuation\">(</span>history<span class=\"token punctuation\">,</span> model<span class=\"token punctuation\">,</span> linearized<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> history<span class=\"token punctuation\">.</span>finished<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> linearized\n    minOps <span class=\"token operator\">=</span> history<span class=\"token punctuation\">.</span>getMinOps\n\n    <span class=\"token keyword\">for</span> minO <span class=\"token keyword\">in</span> minOps<span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">(</span>updatedModel<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> model<span class=\"token punctuation\">.</span>execute<span class=\"token punctuation\">(</span>minO<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> response<span class=\"token punctuation\">.</span>matches<span class=\"token punctuation\">(</span>minO<span class=\"token punctuation\">.</span>response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># recursively check until it terminates</span>\n            res <span class=\"token operator\">=</span> lin_check<span class=\"token punctuation\">(</span>\n                history<span class=\"token punctuation\">.</span>remove<span class=\"token punctuation\">(</span>minO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n                updatedModel<span class=\"token punctuation\">,</span> \n                linearized<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>minO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> res<span class=\"token punctuation\">.</span>notErr<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> res\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">continue</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">continue</span>\n    <span class=\"token keyword\">return</span> error<span class=\"token punctuation\">(</span><span class=\"token string\">\"Nothing works\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>minimumOps is a list of operations that are possible to be the next operation, this means the operation cannot happen AFTER any of operation in  <code class=\"language-text\">history</code></p>\n<p>This is a backtracking algorithm, it performs a depth 1st search and backtracks if it reaches failure, to try the next possible operation.</p>\n<p>One challenge is that it is hard to tell if I implemented it correctly, I decided to visualize it.</p>\n<h2>My plan</h2>\n<p>Web is the best UI platform that I know about, thus I decided to start from there.</p>\n<p>The idea is to visualize the search as</p>","frontmatter":{"title":"A failed attempt to visualize linearizability check","date":"January 12, 2020"}}},"pageContext":{"slug":"/learnings/rec-scheme-for-tree/","previous":{"fields":{"slug":"/system-design/distributed-system/"},"frontmatter":{"title":"Things to consider when building distributed system"}},"next":{"fields":{"slug":"/thoughts/process/"},"frontmatter":{"title":"Forming thoughts on how to run Software Teams"}}}},"staticQueryHashes":[]}