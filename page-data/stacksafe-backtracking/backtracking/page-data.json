{"componentChunkName":"component---src-templates-blog-post-js","path":"/stacksafe-backtracking/backtracking/","result":{"data":{"site":{"siteMetadata":{"title":"All models are wrong","author":"Qing Wei"}},"markdownRemark":{"id":"5a2a34e7-70ae-5db9-847d-baef0fdc7ee2","excerpt":"This article is a follow up for my previous post: How to make a loop cancellable?, in previous post we discussed a special loop construct to…","html":"<p>This article is a follow up for my previous post: <a href=\"./cancel-lopp\">How to make a loop cancellable?</a>, in previous post we discussed a special loop construct to make a long running loop cancellable. </p>\n<p>In this post, I will show how to make a recursive backtracking algorithm cancellable, backtracking algorithm is not tail recursive</p>\n<h2>What is backtracking?</h2>\n<p>Backtracking is a technique commonly found in algorithm with a huge search space, the idea is that when the algorithm is exploring the search space, if there is sufficient information to indicate a subpath and all of subsequent paths are invalid, then those path can be skip by returning the control (and possibly the error) to the previous step, this action of returning control to previous step is called backtrack. It is typically used as a form of optimization.</p>\n<p>One way think about it is to visualize a search space as a tree, and the goal is to find specific path (or node) in the tree based on some condition, eg.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    Root\n    /  \\ \n   A    P\n  / \\   / \\\n O  Q  U   L</code></pre></div>\n<p>If there exhibit some inductive property that allow us to invalidate a subtree without fully exploring it, then we can prune the search space and improve efficiency.</p>\n<p>For example, with the tree above, try to find a path starting from <code class=\"language-text\">Root</code> where all non-Root nodes are vowel. If we start with the right hand path, which is <code class=\"language-text\">P</code>, notice that <code class=\"language-text\">P</code> is not a vowel, then we can skip all path after <code class=\"language-text\">P</code>, (ie. P-U, P-L), and instead try a different path.</p>\n<p>Backtracking algorithms are normally expressed in a recursive way as the general pattern is to try a path and if it does not work, try another path, where each step is recursive. They are also not tail-recursive as tail recursive indicate there is no way to return control to a previous step.</p>\n<p>This article aims to show how we can implement backtracking algorithm in a stacksafe way, I will use Scala but the idea applies on all programming language.</p>\n<h3>How recursion works?</h3>\n<p>Before get into solution, it is useful to revisit how recursion actually works under the hood.</p>\n<p>Recursion works by having a function that calls itself. Function calls are typically managed by programming language using stack data structure, called the call stack. </p>\n<p>Each call is modelled by a stack frame, that contains the parameter of the function call, the actual function code, and a return address.  When the language runtime process a stack frame, it does something like the following:</p>\n<ol>\n<li>Compute the result using function params and code from the stack frame</li>\n<li>Pop the stackframe from the call stack</li>\n<li>Return the result to the return address</li>\n</ol>\n<p>A recursive function is a function that repeatedly push stackframes to the call stack, which is why it can sometime cause stack overflow.</p>\n<h3>Solution: Manually manage Stack on heap</h3>\n<p>The idea is fairly straightforward, while the callstack typically has a limit on number of stack frame, the heap memory does not have such limit, we can manage the stack manually on heap to avoid stack overflow.</p>\n<p>Let’s use the earlier tree as an example:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">sealed</span> <span class=\"token keyword\">trait</span> Tree\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> Node<span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">Char</span><span class=\"token punctuation\">,</span> a<span class=\"token operator\">:</span> Tree<span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> Tree<span class=\"token punctuation\">)</span> <span class=\"token keyword\">extends</span> Tree\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> Leaf<span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">Char</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> findAllVowelPath<span class=\"token punctuation\">(</span>tree<span class=\"token operator\">:</span> Tree<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Option<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">Char</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  tree <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> Node<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> \n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>isVowel<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        findAllVowelPath<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">case</span> Some<span class=\"token punctuation\">(</span>vowelsA<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> Some<span class=\"token punctuation\">(</span>v <span class=\"token operator\">:</span><span class=\"token operator\">:</span> vowelsA<span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">case</span> None <span class=\"token keyword\">=></span> \n            <span class=\"token comment\">// point of backtracking</span>\n            findAllVowelPath<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">case</span> Some<span class=\"token punctuation\">(</span>vowelsB<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> Some<span class=\"token punctuation\">(</span>v <span class=\"token operator\">:</span><span class=\"token operator\">:</span> vowelsB<span class=\"token punctuation\">)</span>\n              <span class=\"token keyword\">case</span> None <span class=\"token keyword\">=></span> None\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        None    \n      <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">case</span> Leaf<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>isVowel<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      Some<span class=\"token punctuation\">(</span>v <span class=\"token operator\">:</span><span class=\"token operator\">:</span> Nil<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      None\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The code above is a tree traversal algorithm, it tries to traverse a tree and when it finds a non-vowel character, it returns the control to the previous step by return a None.</p>\n<p>The algorithm is recursive but not tail-rec, meaning it can’t be optimized by Scala compiler to become stack-safe. Note that for tree traversal algorithm, the  </p>","frontmatter":{"title":"Make backtracking algorithm cancellable (Scala)","date":"December 18, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/stacksafe-backtracking/backtracking/","previous":{"fields":{"slug":"/cancel-loop/"},"frontmatter":{"title":"How to make a loop cancellable? (Scala)"}},"next":{"fields":{"slug":"/stateful-app/"},"frontmatter":{"title":"Build Stateful with fs2, cats-effect"}}}}}