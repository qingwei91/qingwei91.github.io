{"componentChunkName":"component---src-templates-blog-post-js","path":"/memory-ordering/","result":{"data":{"site":{"siteMetadata":{"title":"All models are wrong","author":"Qing Wei"}},"markdownRemark":{"id":"2e0c2bc5-9e57-5242-b4b7-5c6df52338da","excerpt":"I am reading the book Rust Atomics and Locks. The book focuses on low level concurrency construct. One part I find confusing is memory…","html":"<p>I am reading the book <a href=\"https://marabos.nl/atomics/\">Rust Atomics and Locks</a>. The book focuses on low level concurrency construct.</p>\n<p>One part I find confusing is memory ordering, I wish to write down my understanding to make sure I really do understand them.</p>\n<p>The rest of text assumes basic knowledge about concurrency, atomics.</p>\n<p>Let’s start with what problem memory ordering is trying to address.</p>\n<h2>Instruction reordering</h2>\n<p>Fundamentally, all code get compiled to machine instructions, they can be largely group into <code class=\"language-text\">data access</code>, <code class=\"language-text\">operation</code> and <code class=\"language-text\">control</code>.</p>\n<p>One interesting thing is that compiler or your process might decide to order them differently from your code. To my knowledge this is mostly for optimization purpose, this reodering does guarantee the same semantic, so that your program’s output/outcome does not change under such reordering.</p>\n<p>However, this guarantee only stand within a single thread/processor context, ie. your program semantic will not change if its a single thread program.</p>\n<p>Here’s a sample code snippet:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> a <span class=\"token operator\">=</span> <span class=\"token number\">8.0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> b <span class=\"token operator\">=</span> <span class=\"token number\">8.0</span><span class=\"token punctuation\">;</span>\n\na <span class=\"token operator\">=</span> <span class=\"token number\">18</span><span class=\"token punctuation\">;</span>\nb <span class=\"token operator\">=</span> <span class=\"token number\">21</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token macro property\">print!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{?:}\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>In practice, maybe the print statement might be executed right after the mutation of <code class=\"language-text\">a</code> variable, before <code class=\"language-text\">b</code> mutation. But the program will end the same, printing 18.</p>\n<p>In a multi-threaded program where more than a thread shares data, there’s no guarantee that the program semantic is identical and consistent though.</p>\n<p>For example,</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">static</span> shared_var_a<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Atomic</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">u32</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Atomic</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">static</span> shared_var_b<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Atomic</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">u32</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Atomic</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">thread_a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    shared_var_a<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    shared_var_b<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token number\">99</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">thread_b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> shared_var_a<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> shared_var_b<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token macro property\">print!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{?:} - {?:}\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>It is reasonable to expect this to print:</p>\n<ul>\n<li>20 - 99</li>\n<li>2 - 2</li>\n<li>20 - 2</li>\n</ul>\n<p>But it can also print <code class=\"language-text\">2 - 99</code>, note this means thread<em>b might observe the change of var</em>b without observing var_a changes. This happens because of reordering.</p>\n<p>Note the code snippet above might not compile, but I hope the point is clear.</p>\n<h2>Enforcing memory ordering</h2>\n<p>How can we understand or control a multi-threaded program behavior when instruction reordering is possible?</p>\n<p>Naively, we can either disable reordering, which typically results in worse performance. Or we can accept it as a fact and write our program to accommodate.</p>\n<p>Both are not ideal, sometime performance is really important, not getting any guarantee is also bad, for example you cant synchronize more than one shared memory across multiple threads.</p>\n<p>To solve this problem, memory ordering was introduced, there are different types of memory ordering.</p>\n<p>Memory ordering can be specified when accessing atomic variables, or via fences.</p>\n<h3>Relaxed ordering</h3>\n<p>Relaxed ordering is the least restricted (thus most performant) ordering. It guarantees that changes of a single atomic variable are observed in the same order, ie changes cannot be observed to go back in time.</p>\n<p>For example</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">static</span> shared_var_a<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Atomic</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">u32</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Atomic</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">thread_a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    shared_var_a<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    shared_var_a<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">thread_b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> shared_var_a<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> shared_var_a<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token macro property\">print!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{?:} - {?:}\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In thread<em>b, b can only be larger or equal to a, b can never be smaller than a, as that implies the 2nd load observe an older value from thread</em>a.</p>\n<p>Otherwise, relaxed does not provide any guarantee, importantly it does not guarantee any ordering across multiple independent variables.</p>\n<h3>Acquire Release ordering</h3>\n<p>A common ordering is called Acquire Release ordering, this ordering works in pair.</p>\n<p>When reading from shared memory, we specify Acquire ordering. When writing to shared memory we specify Release ordering.</p>\n<p>Then we can establish <code class=\"language-text\">Happens before</code> relationship between the write and read operation (ie. between release and acquire).</p>\n<p>The rules are as follow:</p>\n<ol>\n<li>All memory operations that happen before <code class=\"language-text\">Release</code> must stay before <code class=\"language-text\">Release</code></li>\n<li>All memory operations that happen after <code class=\"language-text\">Acquire</code> must stay after <code class=\"language-text\">Acquire</code></li>\n</ol>\n<p>Then when the Acquire operation in Thread A observed change from the Release operation in Thread B, then Thread A and B are said to be synchronized.</p>","frontmatter":{"title":"Attempt to understand memory ordering","date":"March 02, 2024"}}},"pageContext":{"slug":"/memory-ordering/","previous":{"fields":{"slug":"/sqlserver/upsert-perf/"},"frontmatter":{"title":"SQL Server how to write many rows quicker"}},"next":{"fields":{"slug":"/stateful-app/"},"frontmatter":{"title":"Build Stateful with fs2, cats-effect"}}}},"staticQueryHashes":[]}