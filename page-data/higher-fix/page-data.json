{"componentChunkName":"component---src-templates-blog-post-js","path":"/higher-fix/","result":{"data":{"site":{"siteMetadata":{"title":"All models are wrong","author":"Qing Wei"}},"markdownRemark":{"id":"97d9c77e-652e-593a-8c2a-ef555102ca0c","excerpt":"Prerequisite This article assumes the reader already know about Higher Kinded type (HKT) Fix point type Fix point type is a type that…","html":"<h2>Prerequisite</h2>\n<p>This article assumes the reader already know about</p>\n<ul>\n<li>Higher Kinded type (HKT)</li>\n<li>Fix point type</li>\n</ul>\n<p>Fix point type is a type that generically describes recursive data. By abstracting over a recursive data structure, we can define a generic operation that works on any recursive data structure.</p>\n<p>To learn more about HKT and Fix point type, check these links.</p>\n<ul>\n<li><a href=\"https://typelevel.org/blog/2016/08/21/hkts-moving-forward.html\">Typelevel blogs for HKT</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=7xSfLPD6tiQ\">Rob Norris’s awesome video about Fix Point Type and more</a></li>\n<li><a href=\"https://free.cofree.io/2017/11/13/recursion/\">Recursion Schemes in Scala</a></li>\n</ul>\n<h2>Setup</h2>\n<p>You can run all code snippets in <a href=\"https://ammonite.io\">ammonite-repl</a>, for ADT definition, you need to enclose them in a curly brace like <code class=\"language-text\">{ ...adt definition }</code> before pasting to ammonite repl.</p>\n<p>You can find all of the code used in this post <a href=\"https://gist.github.com/qingwei91/8079d8c731d352259e2d6334b2135300\">here</a></p>\n<h2>What is this post about?</h2>\n<p>This post aims to document how to retain type information of Generalized Algebraic Data Type (GADT) with Fix point type. I will illustrate the technique by refactoring a GADT with direct recursion into another GADT without recursion and implement <code class=\"language-text\">catamorphism</code> method for it.</p>\n<p>This technique can be useful when the type param of your original recursive GADT propagates through the layers of your recursive data structure. It might not make sense now, I suggest carry on reading :)</p>\n<p>The following code snippet shows a GADT that describes how to query a recursive data (e.g., JSON). It is super simple, it can only query String or Boolean by path, but we can add things like QueryByWithCondition later (not in the scope of this article).</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token comment\">// simplified</span>\n\n<span class=\"token keyword\">sealed</span> <span class=\"token keyword\">trait</span> Query<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">object</span> QueryString <span class=\"token keyword\">extends</span> Query<span class=\"token punctuation\">[</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">object</span> QueryBool <span class=\"token keyword\">extends</span> Query<span class=\"token punctuation\">[</span><span class=\"token builtin\">Boolean</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> QueryPath<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>path<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">,</span> next<span class=\"token operator\">:</span> Query<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">extends</span> Query<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">// sample data</span>\n\n<span class=\"token comment\">// {</span>\n<span class=\"token comment\">//   \"oh\": {</span>\n<span class=\"token comment\">//     \"my\": \"zsh\"</span>\n<span class=\"token comment\">//   }</span>\n<span class=\"token comment\">// }</span>\n\n\n<span class=\"token comment\">// expression to query _.oh.my from JSON above</span>\n\n<span class=\"token keyword\">val</span> expression <span class=\"token operator\">=</span> QueryPath<span class=\"token punctuation\">(</span><span class=\"token string\">\"oh\"</span><span class=\"token punctuation\">,</span> QueryPath<span class=\"token punctuation\">(</span><span class=\"token string\">\"my\"</span><span class=\"token punctuation\">,</span> QueryString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>As you might have noticed, the <code class=\"language-text\">Query</code> ADT is recursive, and the type param <code class=\"language-text\">A</code> is recursive too, when constructing <code class=\"language-text\">QueryPath</code> which extends <code class=\"language-text\">Query</code>, the type param is determined by the <code class=\"language-text\">next</code> argument of <code class=\"language-text\">QueryPath</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> typeMatch<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">,</span> B<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> A<span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> B<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">implicit</span> eq<span class=\"token operator\">:</span> A<span class=\"token operator\">=</span><span class=\"token operator\">:</span><span class=\"token operator\">=</span>B<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">val</span> queryString <span class=\"token operator\">=</span> QueryPath<span class=\"token punctuation\">(</span><span class=\"token string\">\"my\"</span><span class=\"token punctuation\">,</span> QueryString<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> queryNestedString <span class=\"token operator\">=</span> QueryPath<span class=\"token punctuation\">(</span><span class=\"token string\">\"my\"</span><span class=\"token punctuation\">,</span> QueryPath<span class=\"token punctuation\">(</span><span class=\"token string\">\"oh\"</span><span class=\"token punctuation\">,</span> QueryString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\ntypeMatch<span class=\"token punctuation\">(</span>queryString<span class=\"token punctuation\">,</span> queryNestedString<span class=\"token punctuation\">)</span>   <span class=\"token comment\">// compiles</span></code></pre></div>\n<p>Having a type param is useful because, for any recursive query, we can <code class=\"language-text\">know the result type statically without traversing the tree</code>, which is a runtime property.</p>\n<p>The following steps are common when applying recursion schemes.</p>\n<ol>\n<li>Refactor Recursive ADT to abstract recursion away</li>\n<li>Construct recursive data structure using Fix Point Type</li>\n<li>Define a Functor instance for the new Non-Recursive ADT</li>\n<li>Implement (or use them from a library) operations like <code class=\"language-text\">catamorphism</code> and <code class=\"language-text\">anamorphism</code> on our recursive data structure</li>\n</ol>\n<p>(For common use cases, we can use operations from recursion schemes library, e.g. <a href=\"https://github.com/slamdata/matryoshka\">Matryoshka</a>)</p>\n<p>We are going to follow the same steps here.</p>\n<h3>Step 1: Refactor GADT to remove recursion</h3>\n<p>The goal of this step is to remove recursion from our ADT, in our case, <code class=\"language-text\">QueryPath</code> should no longer refer to <code class=\"language-text\">Query</code> in its definition</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">sealed</span> <span class=\"token keyword\">trait</span> QueryF<span class=\"token punctuation\">[</span><span class=\"token operator\">+</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">object</span> QueryStringF <span class=\"token keyword\">extends</span> QueryF<span class=\"token punctuation\">[</span><span class=\"token builtin\">Nothing</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">object</span> QueryBoolF <span class=\"token keyword\">extends</span> QueryF<span class=\"token punctuation\">[</span><span class=\"token builtin\">Nothing</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">Boolean</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> QueryPathF<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>path<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">,</span> next<span class=\"token operator\">:</span> F<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">extends</span> QueryF<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span></code></pre></div>\n<p>Above is the GADT after transformation, they are suffixed by <code class=\"language-text\">F</code> to differentiate with the previous GADT, few things to note</p>\n<ol>\n<li>We added a Higher Kinded Type (HKT) param <code class=\"language-text\">F[_]</code> to <code class=\"language-text\">Query</code> base trait, and make it a covariant</li>\n<li>On <code class=\"language-text\">QueryStringF</code>, we specify <code class=\"language-text\">Nothing</code> on the <code class=\"language-text\">F[_]</code> position, so that <code class=\"language-text\">QueryStringF</code> is a subtype of <code class=\"language-text\">QueryF</code>, same for <code class=\"language-text\">QueryBoolF</code></li>\n<li>We removed the recursion on <code class=\"language-text\">QueryPathF</code>, by abstracting <code class=\"language-text\">next: QueryF[A]</code> into <code class=\"language-text\">next: F[A]</code>, this is why we have to introduce <code class=\"language-text\">F[_]</code> on <code class=\"language-text\">QueryF</code>, so that we can abstract over the original <code class=\"language-text\">Query[A]</code> which is a HKT.</li>\n</ol>\n<p>Now let’s see how to form a query using the new ADT.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token comment\">// compiles with `-Ypartial-unification` compiler flag</span>\n<span class=\"token keyword\">val</span> expression <span class=\"token operator\">=</span> QueryPathF<span class=\"token punctuation\">(</span><span class=\"token string\">\"oh\"</span><span class=\"token punctuation\">,</span> QueryPathF<span class=\"token punctuation\">(</span><span class=\"token string\">\"my\"</span><span class=\"token punctuation\">,</span> QueryStringF<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>As you can see, it’s similar to our previous example, which is a hint that our new generic representation is as powerful as the previous, more concrete representation in terms of expressivity.</p>\n<h3>Step 2: Construct recursive data structure using Fix Point Type</h3>\n<p>Let’s revise what Fix Point Type is, <code class=\"language-text\">fix</code> is a structure that conforms to the following rule:</p>\n<p><code class=\"language-text\">fix(f) = f(fix(f)) for all f</code></p>\n<p>The rule above is abstract, in the sense that it can apply to different domain, for example when <code class=\"language-text\">f</code> is function, then <code class=\"language-text\">fix</code> is commonly known as <code class=\"language-text\">Y-combinator</code> which describes recursive function, when <code class=\"language-text\">f</code> is a type then we get <code class=\"language-text\">Fix Point Type</code> which describe recursive type.</p>\n<p>Below is a straight forward way to define <code class=\"language-text\">Fix point type</code> in Scala:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> Fix<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>unfix<span class=\"token operator\">:</span> F<span class=\"token punctuation\">[</span>Fix<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>It follows the rule above in that every <code class=\"language-text\">Fix[F]</code> is equivalent to <code class=\"language-text\">F[Fix[F]]</code> for all F.</p>\n<p>Unfortunately, we cannot use this definition of <code class=\"language-text\">Fix</code> to construct a recursive version of <code class=\"language-text\">QueryF</code></p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token comment\">// does not compile</span>\nFix<span class=\"token punctuation\">(</span>QueryPathF<span class=\"token punctuation\">(</span><span class=\"token string\">\"key\"</span><span class=\"token punctuation\">,</span> Fix<span class=\"token punctuation\">(</span>QueryStringF<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Because the type signature does not match, <code class=\"language-text\">Fix</code> constructor takes a type param with <code class=\"language-text\">* -&gt; *</code> kind (commonly pronounce as Star to Star), encoded as <code class=\"language-text\">F[_]</code> in Scala, but <code class=\"language-text\">QueryF</code> has kind of <code class=\"language-text\">(* -&gt; *) -&gt; * -&gt; *</code>, as it takes a <code class=\"language-text\">F[_]</code> and <code class=\"language-text\">A</code> and returns a proper type (ie. a Star type)</p>\n<blockquote>\n<p>Insights: Fundamentally, <code class=\"language-text\">Fix point</code> exists for any kind of functions. The regular <code class=\"language-text\">Fix</code> type is actually a fix point of <code class=\"language-text\">F[_]</code> which is a type level function, it takes a <code class=\"language-text\">F[_]</code> and produce <code class=\"language-text\">F[Fix[F]]</code> </p>\n</blockquote>\n<p>The solution for this problem is to create a different <code class=\"language-text\">Fix</code> type that can handle <code class=\"language-text\">QueryF</code>, which is a different function.</p>\n<p>We can start by writing out the kind/shape of <code class=\"language-text\">QueryF</code>, it looks like this: <code class=\"language-text\">(* -&gt; *) -&gt; * -&gt; *</code>, meaning it takes a type level function and a proper type and returns a proper type.</p>\n<p>The fix point of such a kind should takes this type as an input, and Scala is powerful enough to express such idea using HKT syntax</p>\n<p><code class=\"language-text\">F[_[_], _]</code> is the syntax to represent a type level function with this kind: <code class=\"language-text\">(* -&gt; *) -&gt; * -&gt; *</code>, then our special HFix for QueryF will looks like below:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> HFix<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>unfix<span class=\"token operator\">:</span> F<span class=\"token punctuation\">[</span>HFix<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>This looks a bit scary, let’s try to break it down.</p>\n<ul>\n<li>the 1st type param <code class=\"language-text\">F[_[_], _]</code> is a type constructor that takes 2 type params, a HKT <code class=\"language-text\">* -&gt; *</code> and a proper type <code class=\"language-text\">*</code></li>\n<li>2nd type param is just a proper type, bind to symbol <code class=\"language-text\">A</code></li>\n<li><code class=\"language-text\">unfix</code> becomes <code class=\"language-text\">F[HFix[F, ?], A]</code>, remember <code class=\"language-text\">F</code> takes a <code class=\"language-text\">* -&gt; *</code> on 1st type param, which is the kind of <code class=\"language-text\">HFix[F, ?]</code>, the 2nd type param would then be <code class=\"language-text\">A</code> so that we propagate it across layers of recursion</li>\n</ul>\n<h3>How do we determine the shape of <code class=\"language-text\">HFix</code> ?</h3>\n<p>To determine the shape of <code class=\"language-text\">HFix</code>, let’s go back to basic:</p>\n<blockquote>\n<p>fix(f) = f(fix(f))</p>\n</blockquote>\n<p>With this formula, we use algebra to solve:</p>\n<ul>\n<li>QF = ((* -> *) -> * -> *)</li>\n<li>Fix = QF -> k where QF(k) = k</li>\n<li>QF(k) = k if k = * -> *</li>\n<li>Fix = QF -> * -> * = <code class=\"language-text\">((* -&gt; *) -&gt; * -&gt; *) -&gt; * -&gt; *</code></li>\n</ul>\n<p>The shape of HFix should be <code class=\"language-text\">((* -&gt; *) -&gt; * -&gt; *) -&gt; * -&gt; *</code>, the key is to figure out what <code class=\"language-text\">k</code> should be</p>\n<p>I think it’s worth to emphasize 2 points</p>\n<ol>\n<li>It allows us to relate an extra type param between layers, ie. both <code class=\"language-text\">HFix[F[_[_], _], A]</code> and <code class=\"language-text\">F[HFix[F, ?], A]</code> contains type <code class=\"language-text\">A</code></li>\n<li>It abstracts over a type with this shape <code class=\"language-text\">(* -&gt; *) -&gt; * -&gt; *</code>, encoded as <code class=\"language-text\">F[_[_], _]</code>, which match our <code class=\"language-text\">QueryF</code> type</li>\n</ol>\n<p>Sample usage of <code class=\"language-text\">HFix</code></p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> queryString <span class=\"token operator\">=</span> HFix<span class=\"token punctuation\">(</span>QueryStringF<span class=\"token operator\">:</span> QueryF<span class=\"token punctuation\">[</span>HFix<span class=\"token punctuation\">[</span>Query<span class=\"token punctuation\">,</span><span class=\"token operator\">?</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> queryBool <span class=\"token operator\">=</span> HFix<span class=\"token punctuation\">(</span>QueryBoolF<span class=\"token operator\">:</span> Query<span class=\"token punctuation\">[</span>HFix<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">,</span><span class=\"token operator\">?</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">Boolean</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> queryPath<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">,</span> next<span class=\"token operator\">:</span> HFix<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> HFix<span class=\"token punctuation\">(</span>QueryPathF<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> HFix<span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\nqueryPath<span class=\"token punctuation\">(</span>\n  <span class=\"token string\">\"oh\"</span><span class=\"token punctuation\">,</span>\n  queryPath<span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"my\"</span><span class=\"token punctuation\">,</span>\n    queryString\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span>\n\nres32<span class=\"token operator\">:</span> HFix<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">,</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> HFix<span class=\"token punctuation\">(</span>QueryPathF<span class=\"token punctuation\">(</span><span class=\"token string\">\"oh\"</span><span class=\"token punctuation\">,</span> HFix<span class=\"token punctuation\">(</span>QueryPathF<span class=\"token punctuation\">(</span><span class=\"token string\">\"my\"</span><span class=\"token punctuation\">,</span> HFix<span class=\"token punctuation\">(</span>QueryStringF<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Cool, so we can create a recursive structure that expresses querying a string at path <code class=\"language-text\">oh.my</code>, note the type of this structure is <code class=\"language-text\">HFix[QueryF, String]</code>, which is great because we retain the knowledge that it results in a <code class=\"language-text\">String</code>.</p>\n<h3>Step 3: Define Functor instance for GADT</h3>\n<p>Defining a Functor instance is essential, it describes how to transform recursive data structure. Unfortunately, due to the usage of GADT, a standard Functor wouldn’t work, it’s similar to the issue with standard Fix Point type.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">trait</span> Functor<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>Above is the interface of Functor, we can define <code class=\"language-text\">Functor</code> for any type with kind <code class=\"language-text\">* -&gt; *</code>, but Query has a type of <code class=\"language-text\">(* -&gt; *) -&gt; * -&gt; *</code> as we’ve seen earlier.</p>\n<p>The solution is similar to how to solve the issue with Fix; we need to define another Functor like structure that fit our type.</p>\n<p>When using ordinary ADT, we want a Functor instance so that we can transform the type param of our ADT, eg. <code class=\"language-text\">F[A] =&gt; F[B]</code>, but now we have <code class=\"language-text\">QueryF[F[_], A]</code>, which contains 2 type params, what should we transform?</p>\n<p>The most generic way would be to transform both type params but to simplify the problem, we are only transforming the 1st type param, e.g., <code class=\"language-text\">QueryF[F[_], A] =&gt; QueryF[G[_], A]</code></p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">import</span> $ivy<span class=\"token punctuation\">.</span>`org<span class=\"token punctuation\">.</span>typelevel<span class=\"token operator\">:</span><span class=\"token operator\">:</span>cats<span class=\"token operator\">-</span>core<span class=\"token operator\">:</span><span class=\"token number\">1.6</span><span class=\"token number\">.0</span>`\n\n<span class=\"token keyword\">import</span> cats<span class=\"token punctuation\">.</span>~<span class=\"token operator\">></span>\n\n<span class=\"token keyword\">trait</span> HFunctor<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">def</span> hmap<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> J<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>nt<span class=\"token operator\">:</span> I <span class=\"token operator\">~</span><span class=\"token operator\">></span> J<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> F<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">~</span><span class=\"token operator\">></span> F<span class=\"token punctuation\">[</span>J<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This typeclass describes the ability transform the 1st type param of an arbitrary type F, where F has kind of <code class=\"language-text\">(* -&gt; *) -&gt; * -&gt; *</code>, which is what we need.</p>\n<p>Next, we need to implement an instance of <code class=\"language-text\">HFunctor</code> for <code class=\"language-text\">QueryF</code></p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">implicit</span> <span class=\"token keyword\">val</span> queryHFunctor<span class=\"token operator\">:</span> HFunctor<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> HFunctor<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> hmap<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> J<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>nt<span class=\"token operator\">:</span> I <span class=\"token operator\">~</span><span class=\"token operator\">></span> J<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> QueryF<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">~</span><span class=\"token operator\">></span> QueryF<span class=\"token punctuation\">[</span>J<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">new</span> <span class=\"token punctuation\">(</span>QueryF<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">~</span><span class=\"token operator\">></span> QueryF<span class=\"token punctuation\">[</span>J<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">def</span> apply<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> QueryF<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> QueryF<span class=\"token punctuation\">[</span>J<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n          a <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">case</span> QueryStringF            <span class=\"token keyword\">=></span> QueryStringF\n            <span class=\"token keyword\">case</span> QueryBoolF              <span class=\"token keyword\">=></span> QueryBoolF\n            <span class=\"token keyword\">case</span> query<span class=\"token operator\">:</span> QueryPathF<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span> <span class=\"token keyword\">=></span> QueryPathF<span class=\"token punctuation\">(</span>query<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">,</span> nt<span class=\"token punctuation\">(</span>query<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The implementation is relatively straight-forward, basically we try to handle every case of GADT and change the <code class=\"language-text\">F[_]</code> type param, for bottom type (ie. when F is Nothing), we dont have to change anything because we define F as covariant.</p>\n<h3>Step 4: Implement catamorphism</h3>\n<p>Finally, after all the ceremony, we are in the position to define <code class=\"language-text\">catamorphism</code></p>\n<p>On a high-level view, <code class=\"language-text\">catamorphism</code> is an operation that collapses a recursive structure into a single value by collapsing each layer of the data structure recursively.</p>\n<p>It is generic in that user can define how to collapse each layer.</p>\n<p>It looks like this</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">type</span> HAlgebra<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> G<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> F<span class=\"token punctuation\">[</span>G<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">~</span><span class=\"token operator\">></span> G\n\n<span class=\"token keyword\">def</span> hCata<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> G<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> I<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>alg<span class=\"token operator\">:</span> HAlgebra<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">,</span> G<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>hfix<span class=\"token operator\">:</span> HFix<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">,</span> I<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">implicit</span> F<span class=\"token operator\">:</span> HFunctor<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> G<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">val</span> inner <span class=\"token operator\">=</span> hfix<span class=\"token punctuation\">.</span>unfix\n  <span class=\"token keyword\">val</span> nt <span class=\"token operator\">=</span> F<span class=\"token punctuation\">.</span>hmap<span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">new</span> <span class=\"token punctuation\">(</span>HFix<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">~</span><span class=\"token operator\">></span> G<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">def</span> apply<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>fa<span class=\"token operator\">:</span> HFix<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> G<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> hCata<span class=\"token punctuation\">(</span>alg<span class=\"token punctuation\">,</span> fa<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>inner<span class=\"token punctuation\">)</span>\n  alg<span class=\"token punctuation\">(</span>nt<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The flow of <code class=\"language-text\">hCata</code> is similar to normal <code class=\"language-text\">cata</code> method, by trying to peel off the outer layer of <code class=\"language-text\">HFix[F, I]</code>, we recursively dive into the inner-most layer of the recursive structure, then we apply <code class=\"language-text\">HAlgebra</code> while traversing back to the top layer.</p>\n<p>Note: You can try to implement anamorphism and other operations :D</p>\n<p>We defined everything we need, let’s try to use it.</p>\n<p>We’ll go through 2 examples, using the query we created earlier.</p>\n<p>a) Print recursive query in a human-readable format</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> nestedQuery <span class=\"token operator\">=</span> queryPath<span class=\"token punctuation\">(</span>\n                    <span class=\"token string\">\"oh\"</span><span class=\"token punctuation\">,</span>\n                    queryPath<span class=\"token punctuation\">(</span>\n                      <span class=\"token string\">\"my\"</span><span class=\"token punctuation\">,</span>\n                      queryString\n                    <span class=\"token punctuation\">)</span>\n                  <span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// a trick to fold into String, this is interesting as it shows that</span>\n<span class=\"token comment\">// generalized type constructor is super powerful; it can represent a</span>\n<span class=\"token comment\">// more specialized type easily</span>\n\n<span class=\"token keyword\">type</span> JustString<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">String</span>\n\n<span class=\"token comment\">// important part: convert each layer of query into a string</span>\n<span class=\"token keyword\">val</span> print<span class=\"token operator\">:</span> HAlgebra<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">,</span> JustString<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> HAlgebra<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">,</span> JustString<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">override</span> <span class=\"token keyword\">def</span> apply<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>fa<span class=\"token operator\">:</span> QueryF<span class=\"token punctuation\">[</span>JustString<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> JustString<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    fa <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">case</span> QueryStringF                 <span class=\"token keyword\">=></span> <span class=\"token string\">\"as[String]\"</span>\n      <span class=\"token keyword\">case</span> QueryBoolF                   <span class=\"token keyword\">=></span> <span class=\"token string\">\"as[Bool]\"</span>\n      <span class=\"token keyword\">case</span> q<span class=\"token operator\">:</span> QueryPathF<span class=\"token punctuation\">[</span>JustString<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span> <span class=\"token keyword\">=></span> s<span class=\"token string\">\"${q.path}.${q.next}\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nhCata<span class=\"token punctuation\">(</span>print<span class=\"token punctuation\">,</span> nestedQuery<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// res44: JustString[String] = \"oh.my.as[String]\"</span></code></pre></div>\n<p>b) Convert our query description a circe Decoder</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">import</span> $ivy<span class=\"token punctuation\">.</span>`io<span class=\"token punctuation\">.</span>circe<span class=\"token operator\">:</span><span class=\"token operator\">:</span>circe<span class=\"token operator\">-</span>parser<span class=\"token operator\">:</span><span class=\"token number\">0.10</span><span class=\"token number\">.0</span>`\n\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">io<span class=\"token punctuation\">.</span>circe</span><span class=\"token punctuation\">.</span>Decoder\n\n<span class=\"token keyword\">val</span> toDecoder<span class=\"token operator\">:</span> HAlgebra<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">,</span> Decoder<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> HAlgebra<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">,</span> Decoder<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">override</span> <span class=\"token keyword\">def</span> apply<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>fa<span class=\"token operator\">:</span> QueryF<span class=\"token punctuation\">[</span>Decoder<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Decoder<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> fa <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> QueryBoolF   <span class=\"token keyword\">=></span> Decoder<span class=\"token punctuation\">.</span>decodeBoolean\n    <span class=\"token keyword\">case</span> QueryStringF <span class=\"token keyword\">=></span> Decoder<span class=\"token punctuation\">.</span>decodeString\n    <span class=\"token keyword\">case</span> q<span class=\"token operator\">:</span> QueryPathF<span class=\"token punctuation\">[</span>Decoder<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span> <span class=\"token keyword\">=></span>\n      Decoder<span class=\"token punctuation\">.</span>instance <span class=\"token punctuation\">{</span> cursor <span class=\"token keyword\">=></span>\n        cursor<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">val</span> decoder <span class=\"token operator\">=</span> hCata<span class=\"token punctuation\">(</span>toDecoder<span class=\"token punctuation\">,</span> nestedQuery<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">val</span> json <span class=\"token operator\">=</span> parse<span class=\"token punctuation\">(</span><span class=\"token string\">\"\"\"\n    {\n      \"oh\": {\n        \"my\": \"20202\"\n      }\n    }\n\"\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">.</span>get\n\ndecoder<span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span>json<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Right(\"20202\")</span></code></pre></div>\n<p>I tried to use simpler examples, for more complicated examples, check these projects:</p>\n<ul>\n<li><a href=\"https://github.com/nuttycom/xenomorph/blob/master/modules/argonaut/src/main/scala/xenomorph/argonaut/FromJson.scala#L51\">Xenomorph</a></li>\n<li><a href=\"https://github.com/qingwei91/basil/blob/master/core/src/main/scala/basil/parser/JsonParse.scala#L447\">Basil</a></li>\n</ul>\n<h2>Conclusion:</h2>\n<p>We’ve walked through how to apply recursion schemes on a GADT. The basic idea is similar to applying recursion schemes on ordinary ADT; the main difference is that we need to operate on higher order types, eg.</p>\n<ul>\n<li><code class=\"language-text\">Functor</code> that takes a function (<code class=\"language-text\">* -&gt; *</code>) becomes HFunctor that takes natural transformation <code class=\"language-text\">(* -&gt; *) -&gt; (* -&gt; *)</code></li>\n<li><code class=\"language-text\">Fix</code> with shape <code class=\"language-text\">(* -&gt; *) -&gt; *</code> becomes <code class=\"language-text\">HFix</code> with shape <code class=\"language-text\">((* -&gt; *) -&gt; (* -&gt; *)) -&gt; (* -&gt; *)</code></li>\n<li><code class=\"language-text\">Algebra</code> with <code class=\"language-text\">(* -&gt; *) -&gt; * -&gt; *</code> becomes HAlgebra <code class=\"language-text\">((* -&gt; *) -&gt; (* -&gt; *)) -&gt; (* -&gt; *) -&gt; (* -&gt; *)</code></li>\n</ul>\n<p>Notice there’s a common theme, the number of stars doubled in the process, I haven’t fully understood why but I hope this article is still useful.</p>\n<h2>Credit</h2>\n<p>I learn most of the techniques described here from <a href=\"https://github.com/nuttycom/xenomorph\">Xenomorph</a> by Nuttycom, I find it interesting and thought would be good to write it down.</p>\n<p>Thanks Nuttycomb for sharing his idea with the open source world! I also wish to thanks my coworker <a href=\"https://github.com/Baccata/\">Olivier</a> for introducing the idea of recursion scheme to me, and Alex for correcting me on notation of higher kinded type.</p>","frontmatter":{"title":"Fix point type for GADT (Scala)","date":"February 08, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/higher-fix/","previous":{"fields":{"slug":"/2018-reflection/"},"frontmatter":{"title":"My reflection for 2018"}},"next":{"fields":{"slug":"/cancel-loop/"},"frontmatter":{"title":"How to make a loop cancellable? (Scala)"}}}}}