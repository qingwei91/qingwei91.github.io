{"componentChunkName":"component---src-templates-blog-post-js","path":"/scalameta-tut/","result":{"data":{"site":{"siteMetadata":{"title":"All models are wrong","author":"Qing Wei"}},"markdownRemark":{"id":"d8ec459b-c379-570d-b5d7-0832578c24ff","excerpt":"This is a tutorial to show how to use Scalameta to develop a generic, parameterized annotation.\nTo know how to setup a project to use…","html":"<p>This is a tutorial to show how to use Scalameta to develop a <strong>generic, parameterized annotation</strong>.\nTo know how to setup a project to use <code class=\"language-text\">scalameta</code>, refer to <a href=\"http://scalameta.org/tutorial/#Setup\">official docs</a></p>\n<h2>What is scalameta?</h2>\n<p><a href=\"http://scalameta.org/\">Scala-meta</a> is the de-facto toolkit for metaprogramming in Scala. For those who are new to metaprogramming, it means programming against code/syntax/<a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">AST</a></p>\n<p>Metaprogramming is very useful when you notice a repeating pattern in your code, but you are not able to refactor it due to limitations of the programming language.</p>\n<p>Conceptually, scalameta allows you to access your code as data (Abstract Syntax Tree), and manipulate it at compile time.</p>\n<h2>Problem: Caching</h2>\n<p>Caching is a common technique that almost all programmers are familiar with. In this tutorial, we will develop a <code class=\"language-text\">cache</code> macro that</p>\n<ul>\n<li>has low syntatic overhead, ie. it should not change the cached function much</li>\n<li>able to support different cache storage, eg. In memory cache, elastic search etc</li>\n<li>able to cache methods with multiple arguments</li>\n</ul>\n<h2>Naive implementation</h2>\n<p>Let’s start with a simple implementation without using macro</p>\n<p>Code to support cache function</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">class</span> CacheBackEnd<span class=\"token punctuation\">[</span>K<span class=\"token punctuation\">,</span> V<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">var</span> map <span class=\"token operator\">=</span> mutable<span class=\"token punctuation\">.</span>Map<span class=\"token punctuation\">[</span>K<span class=\"token punctuation\">,</span> V<span class=\"token punctuation\">]</span>     <span class=\"token comment\">// ignore the fact it is not thread safe</span>\n\n  <span class=\"token comment\">// `compute` is a function, only evaluated in case of cache miss</span>\n  <span class=\"token keyword\">def</span> getOrElse<span class=\"token punctuation\">(</span>k<span class=\"token operator\">:</span> K<span class=\"token punctuation\">,</span> compute<span class=\"token operator\">:</span> K <span class=\"token keyword\">=></span> V<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> V <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    map<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span> <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">case</span> Some<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> v       <span class=\"token comment\">// cache hit</span>\n      <span class=\"token keyword\">case</span> None <span class=\"token keyword\">=></span>\n        <span class=\"token keyword\">val</span> v <span class=\"token operator\">=</span> compute<span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span>\n        map <span class=\"token operator\">=</span> map <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">-></span> v<span class=\"token punctuation\">)</span>\n        v\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">def</span> cache<span class=\"token punctuation\">[</span>K<span class=\"token punctuation\">,</span> V<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>fn<span class=\"token operator\">:</span> K <span class=\"token keyword\">=></span> V<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>cacheStorage<span class=\"token operator\">:</span> CacheBackEnd<span class=\"token punctuation\">[</span>K<span class=\"token punctuation\">,</span> V<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> K <span class=\"token keyword\">=></span> V <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">(</span>k<span class=\"token operator\">:</span> K<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span>\n    cacheStorage<span class=\"token punctuation\">.</span>getOrElse<span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">,</span> fn<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Calling cache function</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token comment\">// this is slow .....</span>\n<span class=\"token keyword\">def</span> fib<span class=\"token punctuation\">(</span>i<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span> <span class=\"token operator\">=</span> i <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">case</span> <span class=\"token number\">0</span> <span class=\"token keyword\">=></span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">case</span> <span class=\"token number\">1</span> <span class=\"token keyword\">=></span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">case</span> n <span class=\"token keyword\">=></span> fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">val</span> cacheBackend <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> CacheBackEnd<span class=\"token punctuation\">[</span><span class=\"token builtin\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token keyword\">def</span> cachedFib<span class=\"token punctuation\">(</span>i<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span> <span class=\"token operator\">=</span> cache<span class=\"token punctuation\">(</span>fib<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>cacheBackend<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// alternatively, we can inline the logic</span>\n<span class=\"token keyword\">def</span> cachedFib<span class=\"token punctuation\">(</span>i<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span> <span class=\"token operator\">=</span> cache <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">case</span> <span class=\"token number\">0</span> <span class=\"token keyword\">=></span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">case</span> <span class=\"token number\">1</span> <span class=\"token keyword\">=></span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">case</span> n <span class=\"token keyword\">=></span> fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span>cacheBackend<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span></code></pre></div>\n<h3>Analysis</h3>\n<p><strong>Pros</strong></p>\n<ul>\n<li>it’s simple and easy to understand</li>\n<li>it supports different cache storage</li>\n<li>able to work on methods of different arguments</li>\n</ul>\n<p><strong>Cons</strong></p>\n<ul>\n<li>It is a bit intrusive, notice the implementation of <code class=\"language-text\">cachedFib</code> needs to be changed</li>\n<li>It is awkward to work with functions with multiple arguments, because our CacheBackend can only takes in <code class=\"language-text\">K, V</code> as type param, so if you have a function with signature <code class=\"language-text\">def fn(x: Int, y: Int): Int</code> , you need to combine <code class=\"language-text\">x</code> and <code class=\"language-text\">y</code> into <code class=\"language-text\">(Int, Int)</code> so that it fit into CacheBackend’s type signature</li>\n</ul>\n<p>Let’s see how we can improve it using scala meta.</p>\n<h2>Scalameta Implementation 1</h2>\n<p>Here, we are going to implement cache function as a macro, the end goal is to support syntax like this</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token comment\">// the signature is slightly different, as our macro need to access `get` and `put` method, but not `getOrElse`</span>\n<span class=\"token comment\">// you can implement both signature though</span>\n<span class=\"token keyword\">trait</span> SyncCache<span class=\"token punctuation\">[</span>K<span class=\"token punctuation\">,</span> V<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">def</span> get<span class=\"token punctuation\">(</span>k<span class=\"token operator\">:</span> K<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Option<span class=\"token punctuation\">[</span>V<span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">def</span> put<span class=\"token punctuation\">(</span>k<span class=\"token operator\">:</span> K<span class=\"token punctuation\">,</span> v<span class=\"token operator\">:</span> V<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">val</span> cacheBackend <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> SyncCache<span class=\"token punctuation\">[</span><span class=\"token builtin\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token annotation punctuation\">@cache</span><span class=\"token punctuation\">(</span>cacheBackend<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> fib<span class=\"token punctuation\">(</span>i<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span> <span class=\"token operator\">=</span> i <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">case</span> <span class=\"token number\">0</span> <span class=\"token keyword\">=></span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">case</span> <span class=\"token number\">1</span> <span class=\"token keyword\">=></span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">case</span> n <span class=\"token keyword\">=></span> fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Before we jump into implementation, we can observe a few difference with previous implementation</p>\n<h3>Observations</h3>\n<ul>\n<li>The syntax is cleaner, it does not change the method’s definition at all</li>\n<li>It also supports different cache storage</li>\n<li>Too much MAGIC, how does it even work?</li>\n<li>Does it support function with multiple arguments?</li>\n</ul>\n<p>Let’s answer the 1st question, how does it works?</p>\n<p>Below is the implementation of the <code class=\"language-text\">cache</code> macro, let’s go through the comments to understand what it does</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token comment\">// @param backend - parameter for `cache` annotation</span>\n<span class=\"token keyword\">class</span> cache<span class=\"token punctuation\">[</span>K<span class=\"token punctuation\">,</span> V<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>backend<span class=\"token operator\">:</span> SyncCache<span class=\"token punctuation\">[</span>K<span class=\"token punctuation\">,</span> V<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">extends</span> scala<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span>StaticAnnotation <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\">// @param defn - the annotated method (it can also be other scala building block like class, but we are restricting here</span>\n  <span class=\"token comment\">//               using some checks below</span>\n  inline <span class=\"token keyword\">def</span> apply<span class=\"token punctuation\">(</span>defn<span class=\"token operator\">:</span> <span class=\"token builtin\">Any</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Any</span> <span class=\"token operator\">=</span> meta <span class=\"token punctuation\">{</span>\n\n    defn <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// this annotation should only be annotate on `method`, represented as `Defn.Def` in scalameta's AST</span>\n      <span class=\"token keyword\">case</span> defn<span class=\"token operator\">:</span> Defn<span class=\"token punctuation\">.</span>Def <span class=\"token keyword\">=></span>\n\n        <span class=\"token comment\">// this represent the instatiated annotation, ie. `@cache(xxx)`</span>\n        <span class=\"token keyword\">this</span> <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n\n          <span class=\"token comment\">// Quasiquote in action, it's a way to pattern match scala AST</span>\n          <span class=\"token comment\">//  - `new`               match instantiation</span>\n          <span class=\"token comment\">//  - `$_`                match the name of the annotation</span>\n          <span class=\"token comment\">//  - `[..$tpr]`          match type params and bind to `tpr`</span>\n          <span class=\"token comment\">//  - `($backendParam)`   match SINGLE argument used in instatiation and bind to `backendParam`</span>\n          <span class=\"token comment\">//                        Note: To match multiple arguments or multiple arguments list (curried), you need different                                           syntax</span>\n          <span class=\"token keyword\">case</span> q<span class=\"token string\">\"new $_[..$tpr]($backendParam)\"</span> <span class=\"token keyword\">=></span>\n\n            <span class=\"token comment\">// we use the element we captured to generate code we want, we will look into details next</span>\n            <span class=\"token keyword\">val</span> body<span class=\"token operator\">:</span> Term <span class=\"token operator\">=</span> CacheMacroImpl<span class=\"token punctuation\">.</span>expand<span class=\"token punctuation\">(</span>tpr<span class=\"token punctuation\">,</span> backendParam<span class=\"token punctuation\">,</span> defn<span class=\"token punctuation\">)</span>\n\n            <span class=\"token comment\">// we only want to replace the method body, so this will do</span>\n            defn<span class=\"token punctuation\">.</span>copy<span class=\"token punctuation\">(</span>body <span class=\"token operator\">=</span> body<span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">case</span> x <span class=\"token keyword\">=></span>\n            abort<span class=\"token punctuation\">(</span>s<span class=\"token string\">\"Unrecognized pattern $x\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">case</span> _ <span class=\"token keyword\">=></span>\n        abort<span class=\"token punctuation\">(</span><span class=\"token string\">\"This annotation only works on `def`\"</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\">// abort if annotated to anything other than methods</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>So here is quite some amount of info, especially around quasiquote. You might have a few questions, like what is the type signature of <code class=\"language-text\">tpr</code> that we’ve captured? I will go through them in next section, but here I wish you get familiar with the general flow, basically we are trying to</p>\n<ol>\n<li>use pattern matching to capture relevant information from the AST [Compile Time]</li>\n<li>perform transformation on the AST [Compile Time]</li>\n<li>transformed AST will then get compiled into artifact that is invoked at runtime</li>\n</ol>\n<p>if you’re interested to know more about quasiquote, <a href=\"https://github.com/scalameta/scalameta/blob/master/notes/quasiquotes.md\">here</a> is the reference for all quasiquote syntax</p>\n<p>Now let’s inspect the implementation of AST transformation logic, ie. <code class=\"language-text\">CacheMacroImpl.expand(tpr, backendParam, defn)</code></p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">object</span> CacheMacroImpl <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\">/**\n    *\n    * @param fnTypeParams - Type params of annotation instance, remember our cache macro is generic `class cache[K, V]`,\n                            this will capture Seq(K, V)\n    * @param cacheExpr    - Argument pass to `cache` macro, should be type of `CacheBackEnd[K, V]`\n    * @param annotatedDef - Methods that is annotated\n    */</span>\n  <span class=\"token keyword\">def</span> expand<span class=\"token punctuation\">(</span>fnTypeParams<span class=\"token operator\">:</span> Seq<span class=\"token punctuation\">[</span>Type<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> cacheExpr<span class=\"token operator\">:</span> Term<span class=\"token punctuation\">.</span>Arg<span class=\"token punctuation\">,</span> annotatedDef<span class=\"token operator\">:</span> Defn<span class=\"token punctuation\">.</span>Def<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Term <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">val</span> cache <span class=\"token operator\">=</span> Term<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">(</span>cacheExpr<span class=\"token punctuation\">.</span>syntax<span class=\"token punctuation\">)</span>     <span class=\"token comment\">// convert Term.Arg to Term.Name</span>\n\n    annotatedDef <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Another Quasiquote pattern match</span>\n      <span class=\"token comment\">// - `..$_`                   match any modifier</span>\n      <span class=\"token comment\">// - `def`                    match only method</span>\n      <span class=\"token comment\">// - `$methodName`            bind method name to $methodName</span>\n      <span class=\"token comment\">// - `[..$tps]`               match some type params of method and bind to $tps</span>\n      <span class=\"token comment\">// - `(..$nonCurriedParams)`  match non-curried argument list and binf to $nonCurriedParams</span>\n      <span class=\"token comment\">// - `$rtType`                bind return type to $rtType</span>\n      <span class=\"token comment\">// - `$expr`                  bind method's body to $expr</span>\n      <span class=\"token keyword\">case</span> q<span class=\"token string\">\"..$_ def $methodName[..$tps](..$nonCurriedParams): $rtType = $expr\"</span> <span class=\"token keyword\">=></span>\n\n        <span class=\"token comment\">// here is the trick to handle different arg size</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nonCurriedParams<span class=\"token punctuation\">.</span>size <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n          <span class=\"token comment\">// if only 1 arg, use the arg as key of cache</span>\n          <span class=\"token keyword\">val</span> paramAsArg <span class=\"token operator\">=</span> Term<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">(</span>nonCurriedParams<span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span>\n          q<span class=\"token string\">\"\"\"\n            // here we are generating code that call the CacheBackend\n            val result: ${rtType} = $cache.get($paramAsArg) match {\n              case Some(v) => v\n              case None =>\n                val value = ${expr}\n                $cache.put($paramAsArg, value)\n                value\n            }\n            result\n           \"\"\"</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">val</span> paramAsArg <span class=\"token operator\">=</span> nonCurriedParams<span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>p <span class=\"token keyword\">=></span> Term<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          q<span class=\"token string\">\"\"\"\n\n            // if there are multiple arg, convert them in tuple, as use the tuple as key\n            val result: ${rtType} = $cache.get((..$paramAsArg)) match {\n              case Some(v) => v\n              case None =>\n                val value = ${expr}\n                $cache.put((..$paramAsArg), value)\n                value\n            }\n            result\n           \"\"\"</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">case</span> other <span class=\"token keyword\">=></span> abort<span class=\"token punctuation\">(</span>s<span class=\"token string\">\"Expected non-curried method, got $other\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>I hope the implementation is not too intimidating, it does the following</p>\n<ol>\n<li>Check if the annotation methods is allowed or not (curried method is not allowed)</li>\n<li>\n<p>Check the number of arguments</p>\n<ul>\n<li>If 1, use it as is</li>\n<li>If multiple, convert them into a tuple, and use the tuple as key of cache</li>\n</ul>\n</li>\n<li>\n<p>Try to get data from cache using <code class=\"language-text\">cache.get(key)</code></p>\n<ul>\n<li>If cache hit, return the cached value</li>\n<li>If cache miss, evaluate the original annotated method, cache the result using <code class=\"language-text\">cache.put(k, v)</code>, and return the result</li>\n</ul>\n</li>\n</ol>\n<h3>Analysis</h3>\n<p><strong>Pros</strong></p>\n<ul>\n<li>it supports different cache storage, eg. you could implement a Cache Backend that support TTL</li>\n<li>it has almost zero syntatic overhead on caller</li>\n<li>able to work on methods of different arguments</li>\n</ul>\n<p><strong>Cons</strong></p>\n<ul>\n<li>It is more complicated to implement</li>\n<li>The implementation is harder to debug</li>\n</ul>\n<h2>Conclusion</h2>\n<p>Here we end this tutorial, as we shown how could you create a generic, parameterize macro using scalameta.\nThe code is availble <a href=\"https://github.com/buaya91/scala-cache\">here</a>\nAs an exercise for readers, you can try to improve the cache so that it support async get and put.</p>\n<p>Note: I am not claiming <code class=\"language-text\">cache</code> annotation is a good use-case of macro, ultimately it depends on your team and problem on hand. Nonetheless, I believe everyone should learn a bit of it to enhance your skills, and also to have better understanding on how compiler view your code.</p>","frontmatter":{"title":"Scalameta tutorial: Cache decorator","date":"May 06, 2017"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/scalameta-tut/","previous":{"fields":{"slug":"/multiplayer-game2/"},"frontmatter":{"title":"How multiplayer game sync their state? (Part 2)"}},"next":{"fields":{"slug":"/2018-reflection/"},"frontmatter":{"title":"My reflection for 2018"}}}}}