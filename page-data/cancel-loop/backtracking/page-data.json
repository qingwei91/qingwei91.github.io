{"componentChunkName":"component---src-templates-blog-post-js","path":"/cancel-loop/backtracking/","result":{"data":{"site":{"siteMetadata":{"title":"All models are wrong","author":"Qing Wei"}},"markdownRemark":{"id":"05e84cb4-2c65-54f3-9ef4-05060cda5b22","excerpt":"This article is a follow up for my previous post: How to make a loop cancellable?, in previous post we discussed a special loop construct toâ€¦","html":"<p>This article is a follow up for my previous post: <a href=\"../\">How to make a loop cancellable?</a>, in previous post we discussed a special loop construct to make a long running loop cancellable. </p>\n<p>In this post, I will show how to make a recursive backtracking algorithm cancellable. I wrote this post specifically for backtracking algorithm because backtracking algorithm is not tail recursive, so it is not obvious how to apply non-tail-rec algorithm to the <code class=\"language-text\">cancellableLoop</code> we created earlier.</p>\n<p>Side note: I bumped into this problem when implementing a <a href=\"https://github.com/qingwei91/lolipop/blob/test-distributed-system/core/src/test/scala/raft/proptest/checker/LinearizationCheck.scala#L52\">linearizability checker</a></p>\n<h2>What is backtracking?</h2>\n<p>Backtracking is a technique commonly found in algorithm with a huge search space, the idea is that when the algorithm is exploring the search space, if there is sufficient information to indicate a subpath and all of subsequent paths are invalid, then those path can be skip by returning the control (and possibly the error) to the previous step, this action of returning control to previous step is called backtrack. It is typically used as a form of optimization.</p>\n<p>One way think about it is to visualize a search space as a tree, and the goal is to find specific path (or node) in the tree based on some condition, eg.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">     E\n    /  \\ \n   A    P\n  / \\   / \\\n O  Q  U   L</code></pre></div>\n<p>If there exhibit some inductive property that allow us to invalidate a subtree without fully exploring it, then we can prune the search space and improve efficiency.</p>\n<p>For example, with the tree above, try to find a path starting from <code class=\"language-text\">root</code> where all nodes are vowel. We are starting with <code class=\"language-text\">E</code>, which is a vowel, next we will try the paths. If we start with the right hand path, which is <code class=\"language-text\">P</code>, notice that <code class=\"language-text\">P</code> is not a vowel, then we can skip all path after <code class=\"language-text\">P</code>, (ie. P-U, P-L), and instead try a different path.</p>\n<p>Backtracking algorithms are normally expressed in a recursive way as the general pattern is to try a path and if it does not work, try another path, where each step is recursive. </p>\n<p>They are also not tail-recursive as tail recursive indicate there is no way to return control to a previous step.</p>\n<p>The entry on wikipedia for <a href=\"https://en.wikipedia.org/wiki/Backtracking\">Backtracking</a> is very comprehensive, please refer to it if you like to know more.</p>\n<h3>How recursion works?</h3>\n<p>Before get into solution, it is useful to revisit how recursion actually works under the hood.</p>\n<p>Recursion works by having a function that calls itself. Function calls are typically managed by programming language using stack data structure, called the call stack. </p>\n<p>Each call is modelled by a stack frame, that contains the parameter of the function call, the actual function code, and a return address.  When the language runtime process a stack frame, it does something like the following:</p>\n<ol>\n<li>Compute the result using function params and code from the stack frame</li>\n<li>Pop the stackframe from the call stack</li>\n<li>Return the result to the return address</li>\n</ol>\n<p>A recursive function is a function that repeatedly push stackframes to the call stack, which is why it can sometime cause stack overflow.</p>\n<h3>Cancellable backtracking algorithm</h3>\n<p>Reminder: to make an loop cancellable, we are using the function below that was discussed in <a href=\"../\">previous post</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\">  <span class=\"token keyword\">def</span> cancellableLoop<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> LoopCtx<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>\n    step<span class=\"token operator\">:</span> LoopCtx <span class=\"token keyword\">=></span> Either<span class=\"token punctuation\">[</span>LoopCtx<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>init<span class=\"token operator\">:</span> LoopCtx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">implicit</span> cs<span class=\"token operator\">:</span> ContextShift<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> monad<span class=\"token operator\">:</span> Monad<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> F<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">def</span> inner<span class=\"token punctuation\">(</span>in<span class=\"token operator\">:</span> LoopCtx<span class=\"token punctuation\">,</span> i<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> F<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        cs<span class=\"token punctuation\">.</span>shift<span class=\"token punctuation\">.</span>flatMap<span class=\"token punctuation\">(</span>_ <span class=\"token keyword\">=></span> inner<span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        step<span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">)</span> <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">case</span> Left<span class=\"token punctuation\">(</span>cont<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> inner<span class=\"token punctuation\">(</span>cont<span class=\"token punctuation\">,</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">case</span> Right<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> a<span class=\"token punctuation\">.</span>pure<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    inner<span class=\"token punctuation\">(</span>init<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>We will try to solve the problem of </p>\n<blockquote>\n<p>Finding a path in a binary tree where every node is a vowel letter.</p>\n</blockquote>\n<p>Note: The input is a binary tree and every node has 2 children, and it is not ordered</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">sealed</span> <span class=\"token keyword\">trait</span> Tree\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> Node<span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">Char</span><span class=\"token punctuation\">,</span> a<span class=\"token operator\">:</span> Tree<span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> Tree<span class=\"token punctuation\">)</span> <span class=\"token keyword\">extends</span> Tree\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> Leaf<span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">Char</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">/*\n * Return type is Option[List[Char]]\n * - None if there is no such path\n * - Some(ls) if there is at least 1 path that match our condition\n */</span>\n<span class=\"token keyword\">def</span> findAllVowelPath<span class=\"token punctuation\">(</span>tree<span class=\"token operator\">:</span> Tree<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Option<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">Char</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  tree <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> Node<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> \n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>isVowel<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">val</span> resultA <span class=\"token operator\">=</span> findAllVowelPath<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n        resultA <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">case</span> Some<span class=\"token punctuation\">(</span>vowelsA<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> Some<span class=\"token punctuation\">(</span>v <span class=\"token operator\">::</span> vowelsA<span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">case</span> None <span class=\"token keyword\">=></span> \n            <span class=\"token comment\">// point of backtracking</span>\n            findAllVowelPath<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">case</span> Some<span class=\"token punctuation\">(</span>vowelsB<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> Some<span class=\"token punctuation\">(</span>v <span class=\"token operator\">::</span> vowelsB<span class=\"token punctuation\">)</span>\n              <span class=\"token keyword\">case</span> None <span class=\"token keyword\">=></span> None\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        None    \n      <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">case</span> Leaf<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>isVowel<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      Some<span class=\"token punctuation\">(</span>v <span class=\"token operator\">::</span> Nil<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      None\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The code above is a tree traversal algorithm, it tries to traverse a tree. When it finds a non-vowel character, it <code class=\"language-text\">returns the control</code> to the previous step by returning a None, if it find a vowel character, it will save the value, once it reach the end of a sub-tree, it returns all vowel characters collected when traversing.</p>\n<p>Our goal is to transform this recursive method into a shape that fits <code class=\"language-text\">cancellableLoop</code> signature, which looks like this: <code class=\"language-text\">LoopCtx => Either[LoopCtx, A]</code>, as discussed earlier, this type signature expresses recursion.</p>\n<p>We can first determine the concrete type of <code class=\"language-text\">A</code>, it is the result type we want, so it will be <code class=\"language-text\">Option[List[Char]]</code>. </p>\n<p>What should <code class=\"language-text\">LoopCtx</code> be? For this step function to work, <code class=\"language-text\">LoopCtx</code> needs to fulfill the following requirements:</p>\n<ol>\n<li>Contain all data needed to perform a step, ie. it needs to have <code class=\"language-text\">Tree</code></li>\n<li>It needs to allow backtracking, remember backtracking is the action to return control and result to previous step, so that previous step can continue a different path.</li>\n</ol>\n<p>  We can leverage the knowledge we learned from how recursion works, in essence, we need to manage the call stack using the <code class=\"language-text\">LoopCtx</code> type. </p>\n<p>  Assuming we are talking about recursion in terms of 2 steps, the <code class=\"language-text\">previous</code> step and the <code class=\"language-text\">current</code> step, then previous step is responsible to create a return address (or multiple depends on your algorithm) and current step will have to return the result using the return address provided. </p>\n<p>letâ€™s try to define the step function</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">sealed</span> <span class=\"token keyword\">trait</span> LoopContext\n\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> Root<span class=\"token punctuation\">(</span>tree<span class=\"token operator\">:</span> Tree<span class=\"token punctuation\">)</span> <span class=\"token keyword\">extends</span> LoopContext\n\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> PathA<span class=\"token punctuation\">(</span>tree<span class=\"token operator\">:</span> Tree<span class=\"token punctuation\">,</span> prevContext<span class=\"token operator\">:</span> LoopContext<span class=\"token punctuation\">,</span> accVowels<span class=\"token operator\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">Char</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">extends</span> LoopContext\n\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> PathAFailed<span class=\"token punctuation\">(</span>prevContext<span class=\"token operator\">:</span> LoopContext<span class=\"token punctuation\">)</span> <span class=\"token keyword\">extends</span> LoopContext\n\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> PathB<span class=\"token punctuation\">(</span>tree<span class=\"token operator\">:</span> Tree<span class=\"token punctuation\">,</span> prevContext<span class=\"token operator\">:</span> LoopContext<span class=\"token punctuation\">,</span> accVowels<span class=\"token operator\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">Char</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">extends</span> LoopContext\n\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> PathBFailed<span class=\"token punctuation\">(</span>prevContext<span class=\"token operator\">:</span> LoopContext<span class=\"token punctuation\">)</span> <span class=\"token keyword\">extends</span> LoopContext\n \n<span class=\"token keyword\">def</span> step<span class=\"token punctuation\">(</span>ctx<span class=\"token operator\">:</span> LoopContext<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Either<span class=\"token punctuation\">[</span>LoopContext<span class=\"token punctuation\">,</span> Option<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">Char</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    ctx <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">case</span> Root<span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span>\n        tree <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">case</span> Node<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> \n              <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>isVowel<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                Left<span class=\"token punctuation\">(</span>PathA<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                Right<span class=\"token punctuation\">(</span>None<span class=\"token punctuation\">)</span>    \n              <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">case</span> Leaf<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>isVowel<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              Right<span class=\"token punctuation\">(</span>Some<span class=\"token punctuation\">(</span>v <span class=\"token operator\">::</span> Nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n              Right<span class=\"token punctuation\">(</span>None<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">case</span> curr<span class=\"token annotation punctuation\">@PathA</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">,</span> prev<span class=\"token punctuation\">,</span> accVowels<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> \n        tree <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">case</span> Node<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> \n              <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>isVowel<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                Left<span class=\"token punctuation\">(</span>PathA<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> curr<span class=\"token punctuation\">,</span> accVowels <span class=\"token operator\">:</span><span class=\"token operator\">+</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                Left<span class=\"token punctuation\">(</span>PathAFailed<span class=\"token punctuation\">(</span>prev<span class=\"token punctuation\">.</span>tree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">case</span> Leaf<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>isVowel<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              Right<span class=\"token punctuation\">(</span>Some<span class=\"token punctuation\">(</span>accVowels <span class=\"token operator\">:</span><span class=\"token operator\">+</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n              Left<span class=\"token punctuation\">(</span>PathAFailed<span class=\"token punctuation\">(</span>prev<span class=\"token punctuation\">.</span>tree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">case</span> PathAFailed<span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span>\n        curr<span class=\"token punctuation\">.</span>tree <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n          \n        <span class=\"token punctuation\">}</span>\n        Left<span class=\"token punctuation\">(</span>PathB<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> curr<span class=\"token punctuation\">,</span> accVowels <span class=\"token operator\">:</span><span class=\"token operator\">+</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n\n    <span class=\"token punctuation\">}</span>\n\n\n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"title":"Make backtracking algorithm cancellable (Scala)","date":"December 18, 2019"}}},"pageContext":{"slug":"/cancel-loop/backtracking/","previous":{"fields":{"slug":"/cancel-loop/"},"frontmatter":{"title":"How to make a loop cancellable? (Scala)"}},"next":{"fields":{"slug":"/books-summary/business-dynamics/"},"frontmatter":{"title":"Summary of Business Dynamics"}}}},"staticQueryHashes":[]}