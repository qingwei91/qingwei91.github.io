{"data":{"site":{"siteMetadata":{"title":"All models are wrong","author":"Qing Wei"}},"markdownRemark":{"id":"97d9c77e-652e-593a-8c2a-ef555102ca0c","excerpt":"Prerequisite This article assumes reader already know about Higher Kinded type (HKT) Fix point type Fix point type is a structure to…","html":"<h2>Prerequisite</h2>\n<p>This article assumes reader already know about</p>\n<ul>\n<li>Higher Kinded type (HKT)</li>\n<li>Fix point type</li>\n</ul>\n<p>Fix point type is a structure to describe recursive data in a generic way, ie. it’s capable to describe any recursive data structure, and by abstracting over recursive data structure, we can define generic operation that works on any recursive data structure.</p>\n<p>Resource for HKT and Fix point type</p>\n<ul>\n<li><a href=\"https://typelevel.org/blog/2016/08/21/hkts-moving-forward.html\">Typelevel blogs for HKT</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=7xSfLPD6tiQ\">Rob Norris’s awesome video about Fix Point Type and more</a></li>\n<li><a href=\"https://free.cofree.io/2017/11/13/recursion/\">Recursion Schemes in Scala</a></li>\n</ul>\n<h2>Credit</h2>\n<p>I learn most if not all of the techniques describe here from <a href=\"https://github.com/nuttycom/xenomorph\">Xenomorph</a> by Nuttycom, I find it fascinating and thought would be good to write it down.</p>\n<p>Thanks Nuttycomb for sharing his idea with the open source world!</p>\n<h2>Setup</h2>\n<p>All code snippets can be run in <a href=\"https://ammonite.io\">ammonite-repl</a>, for ADT, you need to enclose them in curly brace like <code class=\"language-text\">{ ...adt definiteion }</code> before pasting to ammonite repl.</p>\n<h2>What this post is about?</h2>\n<p>For the impatient, all code in this post can be found </p>\n<p>This post aims to document how to retain type information of Generalized Algebraic Data Type (GADT) with Fix point type. I will illustrate it by refactoring a GADT with recursion into another GADT without recursion, and implement <code class=\"language-text\">catamorphism</code> method for it.</p>\n<p>This technique can be useful when the type param of your original recursive GADT is determined recursively. It might not makes sense so far, I suggest to carry on reading :)</p>\n<p>The following code snippet shows a GADT that describes Querying recursive data (eg. JSON). It is super simple, it can only query String or Boolean by path, but we can add things like QueryByWithCondition later.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token comment\">// simplified</span>\n\n<span class=\"token keyword\">sealed</span> <span class=\"token keyword\">trait</span> Query<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">object</span> QueryString <span class=\"token keyword\">extends</span> Query<span class=\"token punctuation\">[</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">object</span> QueryBool <span class=\"token keyword\">extends</span> Query<span class=\"token punctuation\">[</span><span class=\"token builtin\">Boolean</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> QueryPath<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>path<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">,</span> next<span class=\"token operator\">:</span> Query<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">extends</span> Query<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">// sample data</span>\n\n<span class=\"token comment\">// {</span>\n<span class=\"token comment\">//   \"oh\": {</span>\n<span class=\"token comment\">//     \"my\": \"zsh\"</span>\n<span class=\"token comment\">//   }</span>\n<span class=\"token comment\">// }</span>\n\n\n<span class=\"token comment\">// expression to query _.oh.my from JSON above</span>\n\n<span class=\"token keyword\">val</span> expression <span class=\"token operator\">=</span> QueryPath<span class=\"token punctuation\">(</span><span class=\"token string\">\"oh\"</span><span class=\"token punctuation\">,</span> QueryPath<span class=\"token punctuation\">(</span><span class=\"token string\">\"my\"</span><span class=\"token punctuation\">,</span> QueryString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>As you might have notice, the <code class=\"language-text\">Query</code> ADT is recursive, and the type param <code class=\"language-text\">A</code> is recursive too, when constructing <code class=\"language-text\">QueryPath</code> which extends <code class=\"language-text\">Query</code>, the type param is determined by the <code class=\"language-text\">next</code> argument of <code class=\"language-text\">QueryPath</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> typeMatch<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">,</span> B<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> A<span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> B<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">implicit</span> eq<span class=\"token operator\">:</span> A<span class=\"token operator\">=</span><span class=\"token operator\">:</span><span class=\"token operator\">=</span>B<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">val</span> queryString <span class=\"token operator\">=</span> QueryPath<span class=\"token punctuation\">(</span><span class=\"token string\">\"my\"</span><span class=\"token punctuation\">,</span> QueryString<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> queryNestedString <span class=\"token operator\">=</span> QueryPath<span class=\"token punctuation\">(</span><span class=\"token string\">\"my\"</span><span class=\"token punctuation\">,</span> QueryPath<span class=\"token punctuation\">(</span><span class=\"token string\">\"oh\"</span><span class=\"token punctuation\">,</span> QueryString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\ntypeMatch<span class=\"token punctuation\">(</span>queryString<span class=\"token punctuation\">,</span> queryNestedString<span class=\"token punctuation\">)</span>   <span class=\"token comment\">// compiles</span></code></pre></div>\n<p>This is useful because for any recursive query, we can know the result type statically.</p>\n<p>To apply recursion scheme, it’s typical to follow the following steps</p>\n<ol>\n<li>Refactor Recursive ADT to abstract recursion away</li>\n<li>Construct recursive data structure using Fix Point Type</li>\n<li>Define a Functor instance for the new Non-Recursive ADT</li>\n<li>Implement (or use them from library) operations like <code class=\"language-text\">catamorphism</code> and <code class=\"language-text\">anamorphism</code> on our recursive data structure</li>\n</ol>\n<p>(For common use case, we can use operations from recursion schemes library, eg. <a href=\"https://github.com/slamdata/matryoshka\">Matryoshka</a>)</p>\n<p>We are going to follow the same steps here.</p>\n<h3>Step 1: Refactor GADT to remove recursion</h3>\n<p>The goal of this step is to remove recursion from our ADT, in our case, <code class=\"language-text\">QueryPath</code> should no longer refer to <code class=\"language-text\">Query</code> in it’s definition</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">sealed</span> <span class=\"token keyword\">trait</span> QueryF<span class=\"token punctuation\">[</span><span class=\"token operator\">+</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">object</span> QueryStringF <span class=\"token keyword\">extends</span> QueryF<span class=\"token punctuation\">[</span><span class=\"token builtin\">Nothing</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">object</span> QueryBoolF <span class=\"token keyword\">extends</span> QueryF<span class=\"token punctuation\">[</span><span class=\"token builtin\">Nothing</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">Boolean</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> QueryPathF<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>path<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">,</span> next<span class=\"token operator\">:</span> F<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">extends</span> QueryF<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span></code></pre></div>\n<p>Above is the GADT after transformation, they are suffixed by <code class=\"language-text\">F</code> to differentiate with the previous GADT, few things to note</p>\n<ol>\n<li>We added a Higher Kinded Type (HKT) param <code class=\"language-text\">F[_]</code> to <code class=\"language-text\">Query</code> base trait, and make it a covariant</li>\n<li>On <code class=\"language-text\">QueryStringF</code>, we specify <code class=\"language-text\">Nothing</code> on the <code class=\"language-text\">F[_]</code> position, so that <code class=\"language-text\">QueryStringF</code> is a subtype of <code class=\"language-text\">QueryF</code>, same for <code class=\"language-text\">QueryBoolF</code></li>\n<li>We removed the recursion on <code class=\"language-text\">QueryPathF</code>, by abstracting <code class=\"language-text\">next: QueryF[A]</code> into <code class=\"language-text\">next: F[A]</code>, this is why we have to introduce <code class=\"language-text\">F[_]</code> on <code class=\"language-text\">QueryF</code>, so that we can abstract over the original <code class=\"language-text\">Query[A]</code> which is a HKT.</li>\n</ol>\n<p>Now let’s see how to form a query using the new ADT</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token comment\">// compiles with `-Ypartial-unification` compiler flag</span>\n<span class=\"token keyword\">val</span> expression <span class=\"token operator\">=</span> QueryPathF<span class=\"token punctuation\">(</span><span class=\"token string\">\"oh\"</span><span class=\"token punctuation\">,</span> QueryPathF<span class=\"token punctuation\">(</span><span class=\"token string\">\"my\"</span><span class=\"token punctuation\">,</span> QueryStringF<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>As you can see, it’s similar with our previous example, which is a hint that our new generic representation is as powerful as the previous, more concrete representation in terms of expressivity.</p>\n<h3>Step 2: Construct recursive data structure using Fix Point Type</h3>\n<p>Let’s revise what Fix Point Type is, <code class=\"language-text\">fix</code> is a structure that conforms to the following rule:</p>\n<p><code class=\"language-text\">fix(f) = f(fix(f)) for all f</code></p>\n<p>The rule above is abstract, in the sense that it can apply to different domain, for example when <code class=\"language-text\">f</code> is function, then <code class=\"language-text\">fix</code> is commonly known as <code class=\"language-text\">Y-combinator</code> which describes recursive function, when <code class=\"language-text\">f</code> is a type then we get <code class=\"language-text\">Fix Point Type</code> which describe recursive type.</p>\n<p>Below is a straight forward way to define <code class=\"language-text\">Fix point type</code> in scala:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> Fix<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>unfix<span class=\"token operator\">:</span> F<span class=\"token punctuation\">[</span>Fix<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>It follows the rule above in that every <code class=\"language-text\">Fix[F]</code> is equivalent to <code class=\"language-text\">F[Fix[F]]</code> for all F.</p>\n<p>Unfortunately, we cannot use this definition of <code class=\"language-text\">Fix</code> to construct a recursive version of <code class=\"language-text\">QueryF</code></p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token comment\">// does not compile</span>\nFix<span class=\"token punctuation\">(</span>QueryPathF<span class=\"token punctuation\">(</span><span class=\"token string\">\"key\"</span><span class=\"token punctuation\">,</span> Fix<span class=\"token punctuation\">(</span>QueryStringF<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Because the type signature does not match, <code class=\"language-text\">Fix</code> constructor takes a type param with <code class=\"language-text\">* -&gt; *</code> kind (commonly pronounce as Star to Star), encoded as <code class=\"language-text\">F[_]</code> in Scala, but <code class=\"language-text\">QueryF</code> has kind of <code class=\"language-text\">(* -&gt; *) -&gt; * -&gt; *</code>, as it takes a <code class=\"language-text\">F[_]</code> and <code class=\"language-text\">A</code> and returns a proper type (ie. a Star type)</p>\n<p>The solution for this problem is to create a new <code class=\"language-text\">HFix</code> type that matches the type signature of <code class=\"language-text\">QueryF</code></p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> HFix<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>unfix<span class=\"token operator\">:</span> F<span class=\"token punctuation\">[</span>HFix<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>This looks a bit scary, let’s try to break it down</p>\n<ul>\n<li>the 1st type param <code class=\"language-text\">F[_[_], _]</code> is a type constructor that takes 2 type params, a HKT <code class=\"language-text\">* -&gt; *</code> and a proper type <code class=\"language-text\">*</code></li>\n<li>2nd type param is just a proper type, bind to symbol <code class=\"language-text\">A</code></li>\n<li><code class=\"language-text\">unfix</code> becomes <code class=\"language-text\">F[HFix[F, ?], A]</code>, remember <code class=\"language-text\">F</code> takes a <code class=\"language-text\">* -&gt; *</code> on 1st type param, which is the kind of <code class=\"language-text\">HFix[F, ?]</code>, the 2nd type param would then be <code class=\"language-text\">A</code> so that we propagate it across layers of recursion</li>\n</ul>\n<p>I think it’s worth to emphasis 2 points</p>\n<ol>\n<li>It allows us to relate an extra type param between layers, ie. both <code class=\"language-text\">HFix[F[_[_], _], A]</code> and <code class=\"language-text\">F[HFix[F, ?], A]</code> contains type <code class=\"language-text\">A</code></li>\n<li>It abstracts over a type with this shape <code class=\"language-text\">(* -&gt; *) -&gt; * -&gt; *</code>, encoded as <code class=\"language-text\">F[_[_], _]</code>, which match our <code class=\"language-text\">QueryF</code> type</li>\n</ol>\n<p>Sample usage of <code class=\"language-text\">HFix</code></p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> queryString <span class=\"token operator\">=</span> HFix<span class=\"token punctuation\">(</span>QueryStringF<span class=\"token operator\">:</span> QueryF<span class=\"token punctuation\">[</span>HFix<span class=\"token punctuation\">[</span>Query<span class=\"token punctuation\">,</span><span class=\"token operator\">?</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> queryBool <span class=\"token operator\">=</span> HFix<span class=\"token punctuation\">(</span>QueryBoolF<span class=\"token operator\">:</span> Query<span class=\"token punctuation\">[</span>HFix<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">,</span><span class=\"token operator\">?</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">Boolean</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> queryPath<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">,</span> next<span class=\"token operator\">:</span> HFix<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> HFix<span class=\"token punctuation\">(</span>QueryPathF<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> HFix<span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\nqueryPath<span class=\"token punctuation\">(</span>\n  <span class=\"token string\">\"oh\"</span><span class=\"token punctuation\">,</span>\n  queryPath<span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"my\"</span><span class=\"token punctuation\">,</span>\n    queryString\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span>\n\nres32<span class=\"token operator\">:</span> HFix<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">,</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> HFix<span class=\"token punctuation\">(</span>QueryPathF<span class=\"token punctuation\">(</span><span class=\"token string\">\"oh\"</span><span class=\"token punctuation\">,</span> HFix<span class=\"token punctuation\">(</span>QueryPathF<span class=\"token punctuation\">(</span><span class=\"token string\">\"my\"</span><span class=\"token punctuation\">,</span> HFix<span class=\"token punctuation\">(</span>QueryStringF<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Cool, so we are able to create a recursive structure that express querying a string at path <code class=\"language-text\">oh.my</code>, note the type of this structure is <code class=\"language-text\">HFix[QueryF, String]</code>, which is great because we retain the knowledge that it will result in a <code class=\"language-text\">String</code>.</p>\n<h3>Step 3: Define Functor instance for GADT</h3>\n<p>Defining a Functor instance is essential, it describe how to transform recursive data structure. Unfortunately, due to usage of GADT, a normal Functor wouldn’t work, it’s similar to the issue with normal <code class=\"language-text\">Fix</code></p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">trait</span> Functor<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>Above is the interface of Functor, we can define <code class=\"language-text\">Functor</code> for any type with kind <code class=\"language-text\">* -&gt; *</code>, but Query has a type of <code class=\"language-text\">(* -&gt; *) -&gt; * -&gt; *</code> as we’ve seen earlier.</p>\n<p>The solution is similar to how to solve issue with Fix, we need to define another Functor like structure that fit our type.</p>\n<p>When using common ADT, we want a Functor instance so that we can transform the type param of our ADT, eg. <code class=\"language-text\">F[A] =&gt; F[B]</code>, but now we have <code class=\"language-text\">QueryF[F[_], A]</code>, which contains 2 type params, what should we tranform?</p>\n<p>The most generic way would be to transform both type params, but to simplify the problem, we will only transform the 1st type param, eg. <code class=\"language-text\">QueryF[F[_], A] =&gt; QueryF[G[_], A]</code></p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">import</span> $ivy<span class=\"token punctuation\">.</span>`org<span class=\"token punctuation\">.</span>typelevel<span class=\"token operator\">:</span><span class=\"token operator\">:</span>cats<span class=\"token operator\">-</span>core<span class=\"token operator\">:</span><span class=\"token number\">1.6</span><span class=\"token number\">.0</span>`\n\n<span class=\"token keyword\">import</span> cats<span class=\"token punctuation\">.</span>~<span class=\"token operator\">></span>\n\n<span class=\"token keyword\">trait</span> HFunctor<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">def</span> hmap<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> J<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>nt<span class=\"token operator\">:</span> I <span class=\"token operator\">~</span><span class=\"token operator\">></span> J<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> F<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">~</span><span class=\"token operator\">></span> F<span class=\"token punctuation\">[</span>J<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This typeclass describes the ability transform the 1st type param of an arbitrary type F, where F has kind of <code class=\"language-text\">(* -&gt; *) -&gt; * -&gt; *</code>, which is what we need.</p>\n<p>Next we need to implement an instance of <code class=\"language-text\">HFunctor</code> for <code class=\"language-text\">QueryF</code></p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">implicit</span> <span class=\"token keyword\">val</span> queryHFunctor<span class=\"token operator\">:</span> HFunctor<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> HFunctor<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> hmap<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> J<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>nt<span class=\"token operator\">:</span> I <span class=\"token operator\">~</span><span class=\"token operator\">></span> J<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> QueryF<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">~</span><span class=\"token operator\">></span> QueryF<span class=\"token punctuation\">[</span>J<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">new</span> <span class=\"token punctuation\">(</span>QueryF<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">~</span><span class=\"token operator\">></span> QueryF<span class=\"token punctuation\">[</span>J<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">def</span> apply<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> QueryF<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> QueryF<span class=\"token punctuation\">[</span>J<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n          a <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">case</span> QueryStringF            <span class=\"token keyword\">=></span> QueryStringF\n            <span class=\"token keyword\">case</span> QueryBoolF              <span class=\"token keyword\">=></span> QueryBoolF\n            <span class=\"token keyword\">case</span> query<span class=\"token operator\">:</span> QueryPathF<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span> <span class=\"token keyword\">=></span> QueryPathF<span class=\"token punctuation\">(</span>query<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">,</span> nt<span class=\"token punctuation\">(</span>query<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The implementation is relatively straight-forward, basically we try to handle every case of GADT and change the <code class=\"language-text\">F[_]</code> type param, for bottom type (ie. when F is Nothing), we dont have to change anything because we define F as covariant.</p>\n<h3>Step 4: Implement catamorphism</h3>\n<p>Finally, after all the ceremony, we are in the position to define <code class=\"language-text\">catamorphism</code></p>\n<p>On a high level view, <code class=\"language-text\">catamorphism</code> is an operation that collapse a recursive structure into a single value by collapsing each layer of the data structure recursively.</p>\n<p>It is generic in that user can define how to collapse each layer.</p>\n<p>It looks like this</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">type</span> HAlgebra<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> G<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> F<span class=\"token punctuation\">[</span>G<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">~</span><span class=\"token operator\">></span> G\n\n<span class=\"token keyword\">def</span> hCata<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> G<span class=\"token punctuation\">[</span>_<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> I<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>alg<span class=\"token operator\">:</span> HAlgebra<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">,</span> G<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>hfix<span class=\"token operator\">:</span> HFix<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">,</span> I<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">implicit</span> F<span class=\"token operator\">:</span> HFunctor<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> G<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">val</span> inner <span class=\"token operator\">=</span> hfix<span class=\"token punctuation\">.</span>unfix\n  <span class=\"token keyword\">val</span> nt <span class=\"token operator\">=</span> F<span class=\"token punctuation\">.</span>hmap<span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">new</span> <span class=\"token punctuation\">(</span>HFix<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">~</span><span class=\"token operator\">></span> G<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">def</span> apply<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>fa<span class=\"token operator\">:</span> HFix<span class=\"token punctuation\">[</span>F<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> G<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> hCata<span class=\"token punctuation\">(</span>alg<span class=\"token punctuation\">,</span> fa<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>inner<span class=\"token punctuation\">)</span>\n  alg<span class=\"token punctuation\">(</span>nt<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The flow of <code class=\"language-text\">hCata</code> is similar to normal <code class=\"language-text\">cata</code> method, by trying to peel off the outer layer of <code class=\"language-text\">HFix[F, I]</code>, we recursively dive into the inner-most layer of the recursive structure, then we apply <code class=\"language-text\">HAlgebra</code> while traversing back to the top layer.</p>\n<p>Note: You can try to implement anamorphism and other operations :D</p>\n<p>Now that we’ve define everything we need, let’s try to use it.</p>\n<p>We’ll go through 2 examples, using the query we created earlier.</p>\n<p>a) Print recursive query in a human-readable format</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> nestedQuery <span class=\"token operator\">=</span> queryPath<span class=\"token punctuation\">(</span>\n                    <span class=\"token string\">\"oh\"</span><span class=\"token punctuation\">,</span>\n                    queryPath<span class=\"token punctuation\">(</span>\n                      <span class=\"token string\">\"my\"</span><span class=\"token punctuation\">,</span>\n                      queryString\n                    <span class=\"token punctuation\">)</span>\n                  <span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// a trick to fold into String, this is interesting as it shows that</span>\n<span class=\"token comment\">// generalized type constructor is super powerful, it can be changed into a</span>\n<span class=\"token comment\">// more specialized type easily</span>\n\n<span class=\"token keyword\">type</span> JustString<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">String</span>\n\n<span class=\"token comment\">// important part: convert each layer of query into a string</span>\n<span class=\"token keyword\">val</span> print<span class=\"token operator\">:</span> HAlgebra<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">,</span> JustString<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> HAlgebra<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">,</span> JustString<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">override</span> <span class=\"token keyword\">def</span> apply<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>fa<span class=\"token operator\">:</span> QueryF<span class=\"token punctuation\">[</span>JustString<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> JustString<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    fa <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">case</span> QueryStringF                 <span class=\"token keyword\">=></span> <span class=\"token string\">\"as[String]\"</span>\n      <span class=\"token keyword\">case</span> QueryBoolF                   <span class=\"token keyword\">=></span> <span class=\"token string\">\"as[Bool]\"</span>\n      <span class=\"token keyword\">case</span> q<span class=\"token operator\">:</span> QueryPathF<span class=\"token punctuation\">[</span>JustString<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span> <span class=\"token keyword\">=></span> s<span class=\"token string\">\"${q.path}.${q.next}\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nhCata<span class=\"token punctuation\">(</span>print<span class=\"token punctuation\">,</span> nestedQuery<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// res44: JustString[String] = \"oh.my.as[String]\"</span></code></pre></div>\n<p>b) Convert our query description a circe Decoder</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">import</span> $ivy<span class=\"token punctuation\">.</span>`io<span class=\"token punctuation\">.</span>circe<span class=\"token operator\">:</span><span class=\"token operator\">:</span>circe<span class=\"token operator\">-</span>parser<span class=\"token operator\">:</span><span class=\"token number\">0.10</span><span class=\"token number\">.0</span>`\n\n<span class=\"token keyword\">import</span> io<span class=\"token punctuation\">.</span>circe<span class=\"token punctuation\">.</span>Decoder\n\n<span class=\"token keyword\">val</span> toDecoder<span class=\"token operator\">:</span> HAlgebra<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">,</span> Decoder<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> HAlgebra<span class=\"token punctuation\">[</span>QueryF<span class=\"token punctuation\">,</span> Decoder<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">override</span> <span class=\"token keyword\">def</span> apply<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>fa<span class=\"token operator\">:</span> QueryF<span class=\"token punctuation\">[</span>Decoder<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Decoder<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> fa <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> QueryBoolF   <span class=\"token keyword\">=></span> Decoder<span class=\"token punctuation\">.</span>decodeBoolean\n    <span class=\"token keyword\">case</span> QueryStringF <span class=\"token keyword\">=></span> Decoder<span class=\"token punctuation\">.</span>decodeString\n    <span class=\"token keyword\">case</span> q<span class=\"token operator\">:</span> QueryPathF<span class=\"token punctuation\">[</span>Decoder<span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">]</span> <span class=\"token keyword\">=></span>\n      Decoder<span class=\"token punctuation\">.</span>instance <span class=\"token punctuation\">{</span> cursor <span class=\"token keyword\">=></span>\n        cursor<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">val</span> decoder <span class=\"token operator\">=</span> hCata<span class=\"token punctuation\">(</span>toDecoder<span class=\"token punctuation\">,</span> nestedQuery<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">val</span> json <span class=\"token operator\">=</span> parse<span class=\"token punctuation\">(</span><span class=\"token string\">\"\"\"\n    {\n      \"oh\": {\n        \"my\": \"20202\"\n      }\n    }\n\"\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">.</span>get\n\ndecoder<span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span>json<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Right(\"20202\")</span></code></pre></div>\n<p>I tried to use simpler examples, for more complicated examples, check these projects:</p>\n<ul>\n<li><a href=\"https://github.com/nuttycom/xenomorph/blob/master/modules/argonaut/src/main/scala/xenomorph/argonaut/FromJson.scala#L51\">Xenomorph</a></li>\n<li><a href=\"https://github.com/qingwei91/basil/blob/master/core/src/main/scala/basil/parser/JsonParse.scala#L447\">Basil</a></li>\n</ul>\n<h2>Conclusions:</h2>\n<p>So we’ve gone through how to apply recursion schemes on GADT, the basic idea is similar when applying recursion schemes on ADT, the main difference is that we need to operate on higher order, eg.</p>\n<ul>\n<li><code class=\"language-text\">Functor</code> that takes a function (<code class=\"language-text\">* -&gt; *</code>) becomes HFunctor that takes natural transformation <code class=\"language-text\">(* -&gt; *) -&gt; (* -&gt; *)</code></li>\n<li><code class=\"language-text\">Fix</code> with shape <code class=\"language-text\">(* -&gt; *) -&gt; *</code> becomes <code class=\"language-text\">HFix</code> with shape <code class=\"language-text\">((* -&gt; *) -&gt; (* -&gt; *)) -&gt; (* -&gt; *)</code></li>\n<li><code class=\"language-text\">Algebra</code> with <code class=\"language-text\">(* -&gt; *) -&gt; * -&gt; *</code> becomes HAlgebra <code class=\"language-text\">(* -&gt; *) -&gt; * -&gt; * -&gt; * -&gt; * -&gt; * -&gt; *</code></li>\n</ul>\n<p>Notice there’s a common theme, the number of star doubled in the process, I have to admit I haven’t fully understand why but I hope this article is still useful.</p>","frontmatter":{"title":"Fix point type for GADT (Scala)","date":"February 08, 2019"}}},"pageContext":{"slug":"/higher-fix/","previous":{"fields":{"slug":"/2018-reflection/"},"frontmatter":{"title":"My reflection for 2018"}},"next":{"fields":{"slug":"/things-bitten-me/draft/"},"frontmatter":{"title":""}}}}