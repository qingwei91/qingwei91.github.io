{"data":{"site":{"siteMetadata":{"title":"All models are wrong","author":"Qing Wei"}},"markdownRemark":{"id":"a48f0b1e-b14a-504d-ae89-85ffb3b8d09e","excerpt":"Recap In  part 1 of the series , we discussed the following: Challenges faced in multiplayer game How to solve unresponsive UI by client…","html":"<h2><span style=\"text-decoration: underline;\">Recap</span></h2>\n<p>In <a href=\"./multiplayer-game1\">part 1 of the series</a>, we discussed the following:</p>\n<ul>\n<li>Challenges faced in multiplayer game</li>\n<li>How to solve unresponsive UI by client predictions</li>\n</ul>\n<p>I did however gloss over essential server implementation details, which\nwe will focus on in this article.</p>\n<p><strong>Disclaimer: I am not a professional game developer, most of\nthe knowledge shared is based on what I read and my experience of\nsmall hobby projects. The main goal of this article is to provide\nan easy to understand introduction for networking in a multiplayer \ngame.</strong></p>\n<h2><span style=\"text-decoration: underline;\">What’s the role of server?</span></h2>\n<p>Let’s start by defining what a server should do, typically a server should serve as</p>\n<p><strong>a) Connection point for players</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">In a multiplayer game, players need to access a common endpoint\nto reach each other, this is one of the roles of a server\nprogram, even in the P2P communication model, there will be a\nconnection point for players to exchange their network\ninformation before a P2P connection can be established.</code></pre></div>\n<p><strong>b) Processing unit</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">In many cases, the server runs the game simulation code, process all\ninputs from player and updates the game state. Note that this is not\nalways the case, some modern games offload lots of processing to the\nclient side. In this article we will assume it&#39;s the server&#39;s\nresponsibility to process the game, ie. Make the game tick.</code></pre></div>\n<p><strong>c) Single source of truth on game state</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">In many multiplayer games, the server program also has authority on \ngame state, the main reason is to prevent cheating, and it&#39;s also\neasier to reason about when there&#39;s is a single point to get the\ncorrect game state.</code></pre></div>\n<h2><span style=\"text-decoration: underline;\">Naive Server Implementation</span></h2>\n<p>Let’s start to implement the server in the most straightforward fashion,\nthen improve from there.</p>\n<p>The core of the game server is a loop that keeps updating the GameState\nusing a player’s input, commonly know as a TICK, the function signature\nis as follows:</p>\n<blockquote>\n<p><span style=\"color: #ff6600;\">(STATE<sub>n</sub> , INPUT<sub>n</sub>) => STATE<sub>n+1</sub></span></p>\n</blockquote>\n<p>A simplified server code snippet would looks like this</p>\n<h3><span style=\"text-decoration: underline;\">Discussion</span></h3>\n<p>I hope the code snippets look intuitive and straightforward, the server simply take all inputs from the buffer and applies them in the next <code class=\"language-text\">TICK</code> function to get new GameState. Let’s call this approach <code class=\"language-text\">Greedy Game Loop</code>, as it tries to process things as fast as it could. It is all good, until we think about our lovely universe where sunlight takes 8 minutes to  reach the earth. </p>\n<p>Latency strikes again!</p>\n<p><img src=\"https://cdn2.hubspot.net/hubfs/323094/qingwei/speed_of_light_meme.jpg\" title=\"speed_of_light_meme.jpg\"></p>\n<p>The fact that the server processes all input from buffer in every <code class=\"language-text\">TICK</code>,\nmeans the GameState will depends on network latency. Diagram\nbelow illustrates why this is a problem</p>\n<p><img src=\"https://github.com/buaya91/image-storage/blob/master/multiplayer-game-networking/server-side-latency-issue-single.png?raw=true\"></p>\n<p>The image shows 2 clients sending inputs to server, we observe 2\ninteresting facts.</p>\n<ol>\n<li>Requests took different time from different client to server, \n<strong>1</strong> unit of time from <span style=\"background-color: #fab9d9;\">Client A</span> to <span style=\"background-color: #ccffcc;\">Server</span>,  <strong>1.5</strong> unit of time from <span style=\"background-color: #ccffff;\">Client B</span> to <span style=\"background-color: #ccffcc;\">Server</span></li>\n<li>Requests took different time from same client to server,\n1st request took <strong>1</strong> unit of time, 2nd request took <strong>2</strong> unit of time.</li>\n</ol>\n<p>In short, latency is inconsistent, even on the same connection.</p>\n<p>Inconsistent latency combined with <strong><code class=\"language-text\">Greedy Game Loop</code></strong> gives several problems, let look at these further.</p>\n<table style=\"border-color: #000000; background-color: #ffffff;\" border=\"3\" cellpadding=\"5\">\n    <tbody>\n        <tr>\n            <td>\n                <h4 style=\"padding-left: 30px;\">Client Side Prediction will&nbsp;not work</h4>\n            </td>\n            <td>\n                <p style=\"text-align: left;\">\n                    <span style=\"font-size: 13px;\">\n                    If&nbsp;we cannot predict when the&nbsp;server would\n                    receive input (due to latency), we can't make any\n                    predictions with high accuracy. (Forgot how Client\n                    Side Prediction works? read&nbsp;\n                    <a href=\"http://www.cakesolutions.net/teamblogs/how-does-multiplayer-game-sync-their-state-part-1#client-side-prediction\">here</a>)\n                    </span>\n                </p>\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <h4 style=\"padding-left: 30px;\">Low latency players&nbsp;get advantages</h4>\n            </td>\n            <td style=\"width: 642px;\">\n                <span style=\"font-size: 13px;\">\n                If input takes a shorter time to reach server, it will\n                be processed sooner, creating unfair advantage for\n                players with fast networks. eg. Two players\n                shoot&nbsp;each other at the same time,\n                they are supposed to kill each other at the same time,\n                but Player B has a lower latency thus killed Player A\n                before Player A's&nbsp;command is processed.\n                </span>\n            </td>\n         </tr>\n    </tbody>\n</table>\n<p>There is a simple solution to mitigate inconsistent latency,\n<a href=\"./multiplayer-game1#lockstep\">Lockstep State Update</a> that we discussed in the previous article. The idea is that server does not proceed until it received input from all players, it has 2 benefits:</p>\n<ul>\n<li>it does not require client side prediction</li>\n<li>all players will appear to have the same latency as the slowest\nplayer, removing the advantage we mentioned</li>\n</ul>\n<p>However, it does not work for fast-paced action games as the\nresponsiveness is low. (More details can be found on previous article,\nthus I will not repeat here.)</p>\n<p>Next section, we will talk about how to make the server side work for\nfast paced games.</p>\n<h2><span style=\"text-decoration: underline;\">Server Reconcilation</span></h2>\n<p>To solve the problem of inaccurate client side predictions, \nwe need to make the client-server interaction more predictable \nfrom the client point of view. When a Player presses a key on client\nside, the client program needs to know when this input would being\nprocessed on server side.</p>\n<p>One possible way is to <strong>let the client suggest when the input should\nbe applied</strong>, this way, client side would be able to predict it\nreliably. The term <code class=\"language-text\">suggest</code> is used as server might reject the\nsuggestion if it’s invalid, for example trying to cast a magic when \nyour magic power is empty.</p>\n<p>The input should be applied shortly after user input, ie.\n<span style=\"color: #993366;\"><strong>T<sub>input</sub> + X</strong></span>,\nwhere X is the delay. The exact value depends on game, normally less\nthan 100ms to be responsive. Note X can also be zero, in this case\nit should happen immediately after user provides input.</p>\n<p>Let’s say we choose X = 30ms, which translates into roughly 1 frame\nfor 30fps (frame per second), and it takes 150ms for input to travel\nto server, there’s a good chance when input reaches the server,\nthe target frame for input had passed.</p>\n<p><img src=\"https://github.com/buaya91/image-storage/blob/master/multiplayer-game-networking/server-side-independent-latency.png?raw=true\"></p>\n<p>Looking at the diagram, User A pressed a key at <strong>T</strong>, which supposed\nto be processed at <strong>T + 30ms</strong>, but the input is received by server\nat <strong>T + 150ms</strong>, due to latency, which already passed <strong>T + 30ms</strong>.\nThis is the problem we are going to solve in this section</p>\n<blockquote>\n<p><strong>How does server apply input that should happen in the past?</strong></p>\n</blockquote>\n<h3><span style=\"text-decoration: underline;\">The Concept</span></h3>\n<p>You might have recalled client side prediction has a similar issue of\nincorrect predictions due to lacking information of opponents, and\nthe incorrect predictions will later be corrected by state updates\nfrom server using <strong><a href=\"./multiplayer-game1#reconcilation\">Reconcilation</a></strong>.\nThe same technique can be used here, the only difference is that\nwe are correcting the GameState on server using user input from clients.</p>\n<p>All user input needs to be tagged with a timestamp, this timestamp will then be used to tell the server when to process this input.</p>\n<p><img src=\"https://github.com/buaya91/image-storage/blob/master/multiplayer-game-networking/server-side-reconcilation1.png?raw=true\"></p>\n<p><sub>Note: On the first dotted line, it’s <span style=\"color: #000000;\"><strong>Time X</strong></span> on Client side, but <span style=\"color: #000000;\"><strong>Time Y</strong></span> on Server side, this is an interesting nature of multiplayer game (and many other distributed system), as client and server <g class=\"gr_ gr_201 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace\" id=\"201\" data-gr-id=\"201\">runs</g> independently, the time of client and server typically will be different,  our algorithm will handle the difference.</sub></p>\n<p>Diagram above shows interaction between 1 Client and the Server,</p>\n<ol>\n<li>Client sends an Input with timestamp telling server this input of\nClient A should happen on <span style=\"color: #ff0000;\">Time X</span>. </li>\n<li>Server received the request on <span style=\"color: #008000;\">Time Y</span>,\nlet’s assume Time X is older than Time Y for the sake of discussion.\nWhen developing our algorithm, we should not\nassume <span style=\"color: #008000;\">Time Y</span> is bigger or less\nthan <span style=\"color: #ff0000;\">Time X<span style=\"color: #000000;\">,\nthis will give us more flexibility.</span></span></li>\n<li><span style=\"color: #ff0000;\"><span style=\"color: #000000;\">\nThe <span style=\"color: #ff0000;\"><strong>RED BOX</strong></span> is where\nreconcilation happens, the server needs to apply the Input X to the\nlatest game state so that it appears that input X happens\non <span style=\"color: #ff0000;\">Time X</span>.</li>\n<li>GameState from server also includes timestamp, which is required \nfor both server side and client side reconcilation.</li>\n</ol>\n<h4>Details of Reconcilation (<strong><span style=\"color: #ff0000;\">the RED BOX</span></strong>)</h4>\n<ol>\n<li>\n<p>Server needs to maintain</p>\n<ul>\n<li><strong><span style=\"color: #000000;\">GameStateHistory        </span></strong><span style=\"color: #000000;\">- history of GameState within a time frame <strong>P</strong>, eg. all GameState since a second ago</span></li>\n<li><strong>ProcessedUserInput</strong> - history of UserInput processed within a time frame <strong>P</strong>, ie. same value as time frame of GameStateHistory</li>\n<li><strong>UnprocessedUserInput</strong> - UserInput received, but not processed yet, also within time frame <strong>P</strong>\n<img src=\"https://github.com/buaya91/image-storage/blob/master/multiplayer-game-networking/server-buffer0.png?raw=true\"></li>\n</ul>\n</li>\n<li>\n<p>When server received an input from user, it should be inserted into the <strong>UnprocessedUserInput</strong>.</p>\n<p><img src=\"https://github.com/buaya91/image-storage/blob/master/multiplayer-game-networking/server-buffer1.png?raw=true\"></p>\n</li>\n<li>\n<p>Next, when server ticks, </p>\n<ol>\n<li>Check if there is any user input in the <strong>UnprocessedUserInput</strong> which is older than the current frame</li>\n<li>If not, you are good, simply run the game logic with latest GameState and corresponding Inputs (if any), and broadcast to clients.</li>\n<li>If yes, it means some of the game states generated previously are wrong due to missing information, we need to correct it</li>\n<li>First we need to find the oldest unprocessed user input, let say it is on Time N, (Tips: this operation is fast if the **UnprocessedUserInput **is sorted).</li>\n<li>Then we need to obtain the corresponding GameState on Time N from <strong>GameStateHistory</strong>, and the processed user input on Time N from <strong>ProcessedUserInput</strong></li>\n<li>Using these 3 pieces of data, we can create a new GameState which is more accurate.\n<img src=\"https://github.com/buaya91/image-storage/blob/master/multiplayer-game-networking/server-buffer2.png?raw=true\"></li>\n<li>Then move the Unprocessed Input N to ProcessedUserInput, so that we can use it for reconcilation in the future.</li>\n<li>Update the GameState N in <strong>GameStateHistory</strong></li>\n<li>Repeat step 4 to 7, for <code class=\"language-text\">N+1, N+2 ...</code>, until we get latest GameState.</li>\n<li>Server sends out the latest frame to all players. </li>\n</ol>\n</li>\n</ol>\n<h3><span style=\"text-decoration: underline;\">Discussion</span></h3>\n<p>Server side reconcilation suffers similar problems as client side\nreconcilation, when we reconcile, it means we did something wrong,\nand we are correcting by changing history. This means we cannot apply\nirreversible outcomes, i.e, killing a players, such irreversible\noutcomes will only be applied when it goes out of the\n<strong>GameStateHistory</strong>, ie. when it cannot be rewriten anymore.</p>\n<p>In addition, the incorrect GameState sometime causes awful UI jump.\nDiagram below illustrate how it happens</p>\n<p><img src=\"https://github.com/buaya91/image-storage/blob/master/multiplayer-game-networking/server-error0.png?raw=true\"></p>\n<p>Entity starts at top left corner, it is moving toward\nright hand side, 5 ticks later, it shifted towards right, but\nthen server received the user input saying that the entity changed\ndirection on Tick N, so the server reconciles the game state, and\nnow suddenly the entity <strong>jumps</strong> to the bottom left on the canvas.</p>\n<p>I might be exaggerating the effect, sometimes entity does not move\nthat much, thus the jump would less obvious, but it is still noticeable\nin many cases. We can control the jump by changing the size\nof <strong>GameStateHistory</strong>, <strong>UnprocessedUserInput</strong> and <strong>ProcessedUserInput</strong>,\nthe smaller the buffer size, the less jump there would be, because\nwe would be less tolerant on input that arrives late, eg. If Input\nthat is late for more than 100ms is ignored, player with ping > 200ms\nwont be able to play the game.</p>\n<blockquote>\n<p>We can trade <strong>network latency tolerance</strong> for more <strong>accurate game state update</strong>,\nor vice versa.</p>\n</blockquote>\n<p>One popular technique to overcome the problem of inaccurate Game State \nis <strong>Entity Interpolation</strong>, the idea is to smoothen the jump by\nspreading it out within a short amount of time.</p>\n<p><img src=\"https://github.com/buaya91/image-storage/blob/master/multiplayer-game-networking/server-error1.png?raw=true\"></p>\n<p>I will not include implementation details of <strong>Entity Interpolation</strong>\nin this article, however some references will be provided at the bottom of article.</p>\n<h2><span style=\"text-decoration: underline;\">Wrapping Up</span></h2>\n<p>We have talked about how both client and server might work in a multiplayer game.</p>\n<p><img src=\"https://github.com/buaya91/image-storage/blob/master/multiplayer-game-networking/wrapup.png?raw=true\">In general, a multiplayer game has 3 loosely coupled loops, <strong>Server Game Loop</strong>, <strong><g class=\"gr_ gr_149 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace\" id=\"149\" data-gr-id=\"149\">Client side</g> prediction Loop</strong>, and <strong><g class=\"gr_ gr_150 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace\" id=\"150\" data-gr-id=\"150\">Client side</g> UI Rendering Loop</strong>. By having some sort of buffer in between them, their execution can be decoupled, giving us <g class=\"gr_ gr_205 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace\" id=\"205\" data-gr-id=\"205\">flexibility</g> to create better gaming experience.</p>\n<h2><span style=\"text-decoration: underline;\">Conclusion</span></h2>\n<p>Here ends my article on Multiplayer games, I learned much of this\nknowledge from experts in this field, building a \n<a href=\"https://github.com/buaya91/scalajs-snake\">simple multiplayer game</a> also helps a lot.\nI’ve only show one way to implement a multiplayer server,\nthere are more other ways, depending on what kind of game you’re\nbuilding, I encourage you to explore some of those ideas by building a simple game.</p>\n<p>Thanks for reading, happy hacking !</p>\n<h2><span style=\"text-decoration: underline;\"><strong>References and Further Reading</strong></span></h2>\n<ul>\n<li>[Entity Interpolation] - <a href=\"http://www.gabrielgambetta.com/fpm3.html\">http://www.gabrielgambetta.com/fpm3.html</a></li>\n<li><a href=\"http://gafferongames.com/networked-physics/snapshots-and-interpolation/\"><span>[Entity Interpolation] - </span>http://gafferongames.com/networked-physics/snapshots-and-interpolation/</a></li>\n<li>[Lag Compensation] - <a href=\"https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking#Lag_compensation\">https://developer.valvesoftware.com/wiki/Source<em>Multiplayer</em>Networking#Lag_compensation</a></li>\n</ul>","frontmatter":{"title":"How multiplayer game sync their state? (Part 2)","date":"May 01, 2017"}}},"pageContext":{"slug":"/multiplayer-game2/","previous":{"fields":{"slug":"/meetings/"},"frontmatter":{"title":"Fantastic meetings and where to find them"}},"next":{"fields":{"slug":"/scalameta-tut/"},"frontmatter":{"title":"Scalameta tutorial: Cache decorator"}}}}