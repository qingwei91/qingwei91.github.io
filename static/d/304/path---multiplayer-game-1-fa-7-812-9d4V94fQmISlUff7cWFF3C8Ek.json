{"data":{"site":{"siteMetadata":{"title":"All models are wrong","author":"Qing Wei"}},"markdownRemark":{"id":"be40b4de-4233-5bd4-ace1-764eb3bbe8b8","excerpt":"The main problem in multiplayer game In multiplayer game, one of the most complex issue is to keep all player’s state in sync with server…","html":"<h3>The main problem in multiplayer game</h3>\n<p>In multiplayer game, one of the most complex issue is to keep all player’s state in sync with server state.\nThere are a few good articles around this topic on the internet. However, some details are missing here and there, which may be confusing for beginners in field of game programming, I hope I can clear things up in this article.</p>\n<p>I’ll present a few techniques commonly used in this problem space.</p>\n<p><strong>Before</strong> we jump into the problem, let’s have an overview on how multiplayer game generally works.</p>\n<p>Typically, a game program needs to simulate</p>\n<blockquote>\n<p>the changes in an environment with respect of time and players input</p>\n</blockquote>\n<p>Game is stateful program, it depends on time (be it real or logical time), for example, PACMAN is simulating an environment that ghosts will keep moving.</p>\n<p>A multiplayer game is no exception, just that the complexity is higher due to interaction between multipler players.</p>\n<p>Let’s use the classic Snake Game as an example, assume we use a server-client settings. The core game logic works like this</p>\n<ol>\n<li>Read user inputs which can be one of [←, ↑, →, ↓], to change the direction of snake.</li>\n<li>Apply user input if any, which change the direction of snake.</li>\n<li>Move snake by 1 unit space</li>\n<li>Check if any snakes bump into enemy/wall/self, remove them from the game.</li>\n<li>Repeat</li>\n</ol>\n<p>This logic will be run at a fixed interval on server side, as below, each loop is a called a <code class=\"language-text\">frame</code> or a <code class=\"language-text\">tick</code></p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">/**\n      * 1. Read user inputs which can be one of [←, ↑, →, ↓], to change the direction of snake.\n      * 2. Apply user input if any, which change the direction of snake.\n      * 3. Move snake by 1 unit space\n      * 4. Check if any snakes bump into enemy/wall/self, remove them from the game.\n      * 5. Broadcast the new game state to all clients\n      */</span>\n      Thread<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>And the simplest client would just listen to server update and render every frame received to players.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">class</span> Client <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">def</span> onServerUpdate<span class=\"token punctuation\">(</span>state<span class=\"token operator\">:</span> GameState<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      renderGameState<span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>The problem</strong>:</p>\n<p>How do we sync the game world between server and different players in real time?</p>\n<h2>Lockstep State update</h2>\n<h3>Concept</h3>\n<p>To make sure all client are in sync, the simplest way is to let client send update to server in a fixed interval,\nlet’s say every 30ms. The update would contains user input, it can also represent <code class=\"language-text\">no user input</code>.</p>\n<p>Once server gather input from <strong>all user</strong>, it can then proceed with next tick using those inputs.</p>\n<p><img src=\"https://raw.githubusercontent.com/buaya91/image-storage/master/multiplayer-game-networking/lockstep-single.png\" alt=\"img\"></p>\n<p>The image above show how one client interact with server, I hope the problem is obivous, client will stay idle from <strong>T0</strong> to <strong>T1</strong>, waiting for server update to proceed. The latency can range from 50ms to 500ms, depending on network quality, and human will notice any delay over 100ms, so freezing the user interface for 200ms can be big problem for some games. This is not the only issue with lockstep approach.</p>\n<p><img src=\"https://raw.githubusercontent.com/buaya91/image-storage/master/multiplayer-game-networking/lockstep-multi.png\" alt=\"img\">\nThis image is slightly more complicated, showing multi-client interaction with server, you can see that client B have a slower network connection, thus although both A and B send input to server at <strong>T0</strong>, update from B reach server at <strong>T2</strong> instead of <strong>T1</strong>, server only proceed once it receive all updates which is <strong>T2</strong>.</p>\n<p>This means</p>\n<blockquote>\n<p>the latency of the game is now the latency of the most lagged player</p>\n</blockquote>\n<p>we are punishing all players because one of them is lagging, eventually all players will leave your game …</p>\n<p>Not to say there’s a possiblity that client B might be disconnected, thus will block the server until connection timeout.</p>\n<h3>Discussion</h3>\n<p>There are some problems including 2 of which we just mentioned :</p>\n<ol>\n<li>Client will not be responding until receive state update from server, horrible user experience.</li>\n<li>Game responsiveness depends on the most lagged players, playing with a friend with DSL connection? Have Fun</li>\n<li>The connection would be really chatty, clients need to send some useless heartbeat data regularly so that server can confirm it have got all information needed to step forward, which is not efficient.</li>\n</ol>\n<p>First of all, certain kind of games are immune to these problems, most <code class=\"language-text\">Turn-based</code> game actually use some variant of\nsuch model, as client are supposed to wait. For slow-paced game, small amount of delay is acceptable too, for example Farm Ville.</p>\n<p>A great example is <strong>Chess</strong>, where 2 players take their own turn, assuming each turn takes 10 secs</p>\n<ol>\n<li>user are expect to wait each other for 10 secs, they can wait</li>\n<li>2 players take turn alternatively, so lagged player does not affect other player</li>\n<li>each turn takes on average 5 secs, 1 request every 5 secs is fine</li>\n</ol>\n<p>But for fast-paced game, like all FPS, all of these problems make lockstep approach not suitable for them.\nWe will see how we can solve these problem in the rest of articles.</p>\n<h2>Client Predictions</h2>\n<p>Let’s first solve the problem of user-responsiveness, game response after 500 millis after user press a key destroy\nthe gaming experience. How to solve this problem?</p>\n<h3>Concept</h3>\n<p>Some of you might have already have the answer, instead of waiting on server update, client can actually emulate the game by running game logic locally (ie. on the client’s machine).</p>\n<p>Let’s assume to produce game state at <code class=\"language-text\">Tn</code>, we need state at <code class=\"language-text\">Tn-1</code> and all user input at <code class=\"language-text\">Tn-1</code>.</p>\n<p><img src=\"https://raw.githubusercontent.com/buaya91/image-storage/master/multiplayer-game-networking/clientprediction-single.png\" alt=\"img\"></p>\n<p>The idea is simple, let’s have a fixed update rate, which is <code class=\"language-text\">1 unit of time</code> in this example, client send input to server at <strong>T0</strong>, and emulate the game state at <strong>T1</strong>, so client can then render the game without having to wait the state update from server, which only arrive at <strong>T3</strong>.</p>\n<p>This approach only works if</p>\n<blockquote>\n<ol>\n<li>Game state update logic is deterministic, ie. no randomness, or in some way, referentially transparent, so that server and client produce the same game state given the same input.</li>\n<li>Client have all information required to run game logic</li>\n</ol>\n</blockquote>\n<p>1 is not always true, but we can try to make it as similar as possible, and ignore the small differences, ie. floating points computation of different platform, use the same seed for pseudo-random algorithm.</p>\n<p>2 is also not true, for example</p>\n<p><img src=\"https://raw.githubusercontent.com/buaya91/image-storage/master/multiplayer-game-networking/clientprediction-multi.png\" alt=\"img\"></p>\n<p>In the image above, Client A still try to emulate game state at <strong>T1</strong> using the information it has from <strong>T0</strong>, but Client B also submitted input at <strong>T0</strong>, which Client A is not aware of, this means Client A’s prediction of <strong>T1</strong> will be wrong. Luckily, since Client A still receive state of <strong>T1</strong> from server, at <strong>T3</strong>, client have the chance to correct it’s mistake.</p>\n<blockquote>\n<p>Client side need to figure out if the previous emulation is correct, and how to resolve the conflicts.</p>\n</blockquote>\n<p>The resolution of conflicts is normally called <strong>Reconcilation</strong>.</p>\n<p>Implementation of <strong>Reconcilation</strong> varies depending on use case, I’ll show a simple one, which we just throw away our prediction and replace it with the correct state from server.</p>\n<ol>\n<li>\n<p>Client need to maintain 2 buffers, one for predictions, one for user input, which can be used to compute predictions.\nRemember, <strong>State Tn</strong> is computed using <strong>State Tn-1</strong> and <strong>Input Tn-1</strong>, it will be empty at first.\n<img src=\"https://raw.githubusercontent.com/buaya91/image-storage/master/multiplayer-game-networking/clientprediction-initbuffer.png\" alt=\"img\"></p>\n</li>\n<li>\n<p>When player press an arrow key, the input in stored in InputBuffer, and client will also produce predictions which is then used to render the view, the prediction is stored in PredictionBuffer.</p>\n<div>\n<img src=\"https://raw.githubusercontent.com/buaya91/image-storage/master/multiplayer-game-networking/clientprediction-buffer1.png\">\n</div>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/buaya91/image-storage/master/multiplayer-game-networking/clientprediction-buffer2.png\" alt=\"img\"></p>\n<ol start=\"3\">\n<li>\n<p>When server State0 is received, and does not match with the client Prediction0, we can replace Prediction0 with State0, and recompute Prediction1 using Input0 and State0.</p>\n<div>\n<img src=\"https://raw.githubusercontent.com/buaya91/image-storage/master/multiplayer-game-networking/clientprediction-reconciledbuffer.png\" style=\"display:block;\">\n</div>\n</li>\n<li>\n<p>After reconcilation, we can safely removed State0 and Input0 from the buffer, as we can confirm we got it correct.\n<img src=\"https://raw.githubusercontent.com/buaya91/image-storage/master/multiplayer-game-networking/clientprediction-droppedbuffer.png\" alt=\"img\"></p>\n</li>\n</ol>\n<p>Note: this reconcilaton comes with a drawback, there might be glitches on view if server state and client prediction differ too much, for example if we predict enemy is moving south on <strong>T0</strong>, but at <strong>T3</strong> we realize it move towards north, and reconcile by simply using state from server, the enemy will bounce from towards north to reflect it’s correct position. There are ways to handle this problem, but it will not be in this article.</p>\n<h3>Discussion</h3>\n<p>Client prediction technique gives us a big benefit</p>\n<blockquote>\n<p>Client run on it’s own update rate, independent to server update rate, so that if server is having hiccups, it does not affect client side frame rate.</p>\n</blockquote>\n<p>It inevitably comes with some complexity :</p>\n<ol>\n<li>We need to handle more state and logic on client side, (Prediction buffer, state buffer, prediction logic).</li>\n<li>We need to decide how to handle conflict between prediction and real state from server.</li>\n</ol>\n<p>And it still leave us with some problem :</p>\n<ol>\n<li>View glitches due to wrong predictions</li>\n<li>Chatty connection</li>\n</ol>\n<h2>Conclusion</h2>\n<p>In this article, we went through 2 ways of approaching multiplayer game networking :</p>\n<ol>\n<li>Lockstep state update</li>\n<li>Client prediction</li>\n</ol>\n<p>Each comes with it’s own set of trade off, so far we havent get a closer look on the server side, which will be covered in next article some time later.</p>\n<p>Thanks for reading !</p>","frontmatter":{"title":"How multiplayer game sync their state? (Part 1)","date":"March 01, 2017"}}},"pageContext":{"slug":"/multiplayer-game1/","previous":null,"next":{"fields":{"slug":"/meetings/"},"frontmatter":{"title":"Fantastic meetings and where to find them"}}}}